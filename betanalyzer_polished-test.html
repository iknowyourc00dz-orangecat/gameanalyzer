<html lang="en"><head>
<meta charset="UTF-8">
<title>Game Coverage Analyzer</title>
<style>
/* ---------- fvcking clankers ---------- */
body { font-family:'Segoe UI', Tahoma, sans-serif; background: radial-gradient(circle at top,#0f0f1a,#050509); color:#e0e0e0; padding:25px; margin:0; }
h1 { text-align:center; font-size:2.6em; color:#00ffff; text-shadow:0 0 12px #00ffff,0 0 25px #00ccff; margin-bottom:30px; letter-spacing:1.5px; }
.container { max-width:1100px; margin:auto; display:grid; gap:25px; }
.card { background:rgba(15,15,25,0.95); border-radius:20px; padding:25px; box-shadow:0 0 18px rgba(0,255,255,0.15); border:1px solid #00ffff55; transition:0.3s; }
.card:hover { box-shadow:0 0 25px rgba(0,255,255,0.35); transform:translateY(-3px); }
label { font-weight:bold; color:#00eaff; margin-top:15px; display:block; font-size:0.95em; }
select,textarea { width:100%; margin-top:8px; margin-bottom:18px; padding:14px; font-size:15px; border-radius:12px; border:1px solid #00ffff55; background:#12121a; color:#e0e0e0; outline:none; }
textarea { resize: vertical; min-height:160px; font-family:"Fira Code", monospace; }
button { width:100%; padding:16px; font-size:18px; font-weight:bold; color:#0a0a0f; background:linear-gradient(135deg,#00ffff,#00ccff); border:none; border-radius:15px; cursor:pointer; box-shadow:0 0 15px #00ffffaa; }
button:hover { background:linear-gradient(135deg,#00ccff,#00ffff); transform:scale(1.04); box-shadow:0 0 20px #00ffff; }
.result-header { display:flex; justify-content:space-between; align-items:center; }
.result-header h2 { font-size:1.4em; color:#00ffff; margin:0; text-shadow:0 0 6px #00ffff; }
.status-badge { padding:6px 12px; border-radius:8px; font-weight:bold; font-size:0.9em; }
.status-arb { background:#00ff66; color:#000; }
.status-notarb { background:#ff4444; color:#fff; }
.status-warning { background:#ffaa00; color:#000; }
.section { margin-top:20px; }
.section h3 { margin:0 0 10px; font-size:1.1em; color:#00eaff; border-bottom:1px solid #00ffff44; padding-bottom:5px; }
.table { width:100%; border-collapse:collapse; margin-top:8px; }
.table th,.table td { padding:8px 12px; border:1px solid #00ffff22; text-align:left; font-size:0.9em; }
.table th { background:#101020; color:#00ffff; }
.badge { padding:3px 8px; border-radius:6px; font-size:0.85em; }
.badge-covered { background:#00ff66aa; color:#000; }
.badge-uncovered { background:#ff4444aa; color:#fff; }
.badge-win { background:#ffaa00; color:#000; }





</style>
</head>
<body>
<div class="container">
  <h1>üé≤ Game Coverage Analyzer</h1>

  <div class="card">
    <label for="gameSelect">üéÆ Select Game</label>
    <select id="gameSelect" class="dropdown">

  <!-- Evolution -->
  <optgroup label="‚ö° Evolution">
    <option value="roulette">Roulette</option>
    <option value="sicbo">Sic Bo</option>
    <!--  <option value="lightningsicbo">Lightning Sic Bo (not working) </option> -->
    <option value="fantan">Fan Tan</option>
    <option value="monopoly">Monopoly Big Baller</option>
    <option value="funkytime">Funky Time</option>
    <option value="crazytime">Crazy Time</option>
    <option value="lightningstorm">Lightning Storm</option>
    <option value="racetrack">Race Track</option>
    <option value="icefishing">Ice Fishing</option>
	<option value="megaball">Mega Ball</option>
	<option value="lightningdice">Lightning Dice</option>
	<option value="crazyballs">Crazy Balls</option>
	<option value="dtp">Dragon Tiger Phoenix</option>
  </optgroup>

  <!-- KingMaker -->
  <optgroup label="üëë KingMaker">
    <option value="sevenupsevendown">7 Up 7 Down</option>
    <option value="kingmaker32">32 Cards</option>
    <option value="numbermatka">Number Matka</option>
     <option value="cointoss">Coin Toss</option>
	 <option value="colorgame">Color Game</option>
	 <option value="andarbahar">Andar Bahar</option>
	 	<option value="ft">Fan Tan (KM)</option>
  </optgroup>

  <!-- Pragmatic Play -->
  <optgroup label="üé∞ Pragmatic Play">
    <option value="megawheel">Casino Mega Wheel</option>
  </optgroup>

</select>

<style>
/* Neon styled dropdown */
.dropdown {
  width: 100%;
  padding: 12px 14px;
  border-radius: 10px;
  border: 1px solid #00ffc6;
  background: #0d0d15;
  color: #e0e0e0;
  font-size: 15px;
  font-weight: 500;
  outline: none;
  cursor: pointer;
  transition: all 0.3s ease;
  appearance: none; /* Remove default arrow */
  background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg fill='%2300ffc6' height='20' viewBox='0 0 24 24' width='20' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 14px center;
  background-size: 16px;
}

/* Hover & focus effects */
.dropdown:hover {
  border-color: #33ffd6;
  box-shadow: 0 0 10px rgba(0, 255, 200, 0.25);
}
.dropdown:focus {
  border-color: #00bfff;
  box-shadow: 0 0 14px rgba(0, 191, 255, 0.6);
}

/* Optgroup style */
.dropdown optgroup {
  font-weight: bold;
  font-size: 14px;
  color: #00ffc6;
  background: #111622;
  padding: 4px;
}

/* Options style */
.dropdown option {
  background: #0d0d15;
  color: #e0e0e0;
  padding: 6px;
  font-size: 14px;
}
</style>



    <label for="jsonInput">üì• Paste JSON Data</label>
    <textarea id="jsonInput" placeholder="[{&quot;code&quot;:&quot;ROU_1&quot;,&quot;stake&quot;:100,&quot;payout&quot;:200}]"></textarea>
    <button onclick="runAnalysis()">üöÄ Run Analysis</button>
  </div>

  <div class="card">
    <div class="result-header">
      <h2>üìä Analysis Result</h2>
      <span id="statusBadge" class="status-badge status-warning">Awaiting...</span>
    </div>
    <div id="resultSections">‚ö° Waiting for input...</div>
  </div>
</div>

<script>
// ----- Roulette Analyzer test -----
function extractRouletteInfo(jsonText){
  const RED=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
  const BLACK=[2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35];
  const ODD=Array.from({length:18},(_,i)=>2*i+1);   // 1,3,5,...,35
  const EVEN=Array.from({length:18},(_,i)=>(i+1)*2); // 2,4,6,...,36

  const DOZEN={
    "ROU_DozenBet112":Array.from({length:12},(_,i)=>i+1),
    "ROU_DozenBet1324":Array.from({length:12},(_,i)=>i+13),
    "ROU_DozenBet2536":Array.from({length:12},(_,i)=>i+25)
  };
  const COLUMN={
    "ROU_ColumnBet1":[1,4,7,10,13,16,19,22,25,28,31,34],
    "ROU_ColumnBet2":[2,5,8,11,14,17,20,23,26,29,32,35],
    "ROU_ColumnBet3":[3,6,9,12,15,18,21,24,27,30,33,36]
  };

  function parseSquare(s){
    const nums=[]; let i=0;
    while(i<s.length && nums.length<3){
      if(i+1<s.length){
        const t=parseInt(s.slice(i,i+2),10);
        if(t>=0&&t<=36){nums.push(t); i+=2; continue;}
      }
      const o=parseInt(s.slice(i,i+1),10);
      if(o>=0&&o<=36) nums.push(o);
      i+=1;
    }
    return nums.length===3?nums:null;
  }

  const covered=new Set(), wins=[], betDetails=[];
  let stakeTotal=0, payoutTotal=0;

  try{
    const data=JSON.parse(jsonText);
    function add(n){if(n>=0&&n<=36) covered.add(n);}

    for(const item of data){
      const code=item.code||"", s=Number(item.stake||0), p=Number(item.payout||0);
      stakeTotal+=s; payoutTotal+=p;
      if(p>0) wins.push({code, stake:s, payout:p});

      // --- Cover Number (e.g. ROU_1936 ‚Üí covers 19‚Äì36) ---
      const cover=code.match(/^ROU_(\d{1,2})(\d{1,2})$/);
      if(cover){
        const start=parseInt(cover[1],10);
        const end=parseInt(cover[2],10);
        for(let n=start;n<=end;n++) add(n);
        continue;
      }

      // Single numbers
      const single=code.match(/^ROU_(\d+)(Red|Black|Green)?$/);
      if(single){add(Number(single[1])); continue;}

      // Dozens
      if(DOZEN[code]){DOZEN[code].forEach(add); continue;}

      // Columns
      if(COLUMN[code]){COLUMN[code].forEach(add); continue;}

      // Split
      const split=code.match(/^ROU_SplitBet(\d+)And(\d+)$/);
      if(split){add(Number(split[1])); add(Number(split[2])); continue;}

      // Line
      const line=code.match(/^ROU_LineBet(\d{1,2})(\d{1,2})(\d{1,2})(\d{1,2})(\d{1,2})And(\d{1,2})$/);
      if(line){for(let i=1;i<=6;i++) add(Number(line[i])); continue;}

      // Corner
      const corner=code.match(/^ROU_CornerBet(\d+)_(\d+)_(\d+)_(\d+)$/);
      if(corner){for(let i=1;i<=4;i++) add(Number(corner[i])); continue;}

      // Street
      const street=code.match(/^ROU_StreetBet(\d+)_(\d+)_(\d+)$/);
      if(street){for(let i=1;i<=3;i++) add(Number(street[i])); continue;}

      // Square
      const square=code.match(/^ROU_SquareBet(\d+)And(\d+)$/);
      if(square){
        const n=parseSquare(square[1]);
        if(n){n.forEach(add); add(Number(square[2]));}
        continue;
      }

      // Even chances
      if(code==="ROU_Red"){RED.forEach(add); continue;}
      if(code==="ROU_Black"){BLACK.forEach(add); continue;}
      if(code==="ROU_Odd"){ODD.forEach(add); continue;}
      if(code==="ROU_Even"){EVEN.forEach(add); continue;}
    }

    const TOTAL=37;
    const all=Array.from({length:TOTAL},(_,i)=>i);
    const sorted=[...covered].sort((a,b)=>a-b);
    const uncovered=all.filter(n=>!covered.has(n));
    const percent=sorted.length/TOTAL*100;
    const status=percent>=85?"ARB ‚úÖ":"NOT ARB ‚ùå";

    return {
      covered:sorted,
      uncovered,
      winningBets:wins,
      totalStake:stakeTotal,
      totalPayout:payoutTotal,
      status,
      coveredPercent:percent
    };
  } catch{
    return null;
  }
}











function runAnalysis() {
  const game = document.getElementById("gameSelect").value;
  const jsonText = document.getElementById("jsonInput").value;
  const result = document.getElementById("resultSections");
  const badge = document.getElementById("statusBadge");

  if (!jsonText) {
    result.innerHTML = "<p>‚ö†Ô∏è Please provide JSON input</p>";
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
    return;
  }
  
  
  
  
  
// ---------- Roulette ----------
if (game === "roulette") {

  let bets;
  try {
    bets = JSON.parse(jsonText);
  } catch (e) {
    result.innerHTML = "<p>‚ö†Ô∏è Invalid JSON or empty input</p>";
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
    return;
  }
  if (!bets || !bets.length) {
    result.innerHTML = "<p>‚ö†Ô∏è No bets placed</p>";
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
    return;
  }

  // --- helper sets ---
  const RED   = [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];
  const BLACK = [2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35];
  const ODD   = Array.from({length:18},(_,i)=>2*i+1).filter(n=>n<=36);
  const EVEN  = Array.from({length:18},(_,i)=>(i+1)*2).filter(n=>n<=36);
  const DOZEN = {
    "ROU_DozenBet112": Array.from({length:12},(_,i)=>i+1),
    "ROU_DozenBet1324": Array.from({length:12},(_,i)=>i+13),
    "ROU_DozenBet2536": Array.from({length:12},(_,i)=>i+25)
  };
  const COLUMN = {
    "ROU_ColumnBet1":[1,4,7,10,13,16,19,22,25,28,31,34],
    "ROU_ColumnBet2":[2,5,8,11,14,17,20,23,26,29,32,35],
    "ROU_ColumnBet3":[3,6,9,12,15,18,21,24,27,30,33,36]
  };

  // --- parse multi-number bets ---
  function parseMultiNumbers(code) {
    const parts = code.split("And").map(s => s.replace(/\D/g, "")).filter(Boolean);
    let numbers = [];

    parts.forEach(part => {
      let i = 0;
      while (i < part.length) {
        let twoDigit = parseInt(part.slice(i, i + 2), 10);
        if (!isNaN(twoDigit) && twoDigit >= 0 && twoDigit <= 36) {
          numbers.push(twoDigit);
          i += 2;
        } else {
          let oneDigit = parseInt(part[i], 10);
          if (!isNaN(oneDigit) && oneDigit >= 0 && oneDigit <= 36) {
            numbers.push(oneDigit);
          }
          i += 1;
        }
      }
    });

    return numbers;
  }

  // --- Helper: decode bet code into numbers ---
  function getCoveredNumbers(code) {
    if (code === "ROU_0" || code === "ROU_0Green") return [0];
    if (code === "ROU_0And1") return [0,1];
    if (code === "ROU_0And2") return [0,2];
    if (code === "ROU_0And3") return [0,3];
    if (code === "ROU_0_1_2") return [0,1,2];
    if (code === "ROU_0_2_3") return [0,2,3];
    if (code === "ROU_0_1_2_3") return [0,1,2,3];

    if (DOZEN[code]) return DOZEN[code];
    if (COLUMN[code]) return COLUMN[code];

    // --- ColumnBetEtc pattern ---
    const columnEtc = code.match(/^ROU_ColumnBet(\d+)Etc$/);
    if (columnEtc) {
      const num = Number(columnEtc[1]);
      if ([1,4,7,10,13,16,19,22,25,28,31,34].includes(num)) return COLUMN["ROU_ColumnBet1"];
      if ([2,5,8,11,14,17,20,23,26,29,32,35].includes(num)) return COLUMN["ROU_ColumnBet2"];
      if ([3,6,9,12,15,18,21,24,27,30,33,36].includes(num)) return COLUMN["ROU_ColumnBet3"];
    }

    // --- Low/High 18 bets (explicit lists) ---
    if (code === "ROU_Low18" || code === "ROU_118")
      return [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18];
    if (code === "ROU_High18" || code === "ROU_1936")
      return [19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36];

    // --- Single number ---
    const single = code.match(/^ROU_(\d+)(Red|Black|Green)?$/);
    if (single) return [Number(single[1])];

    // --- Split ---
    const split = code.match(/^ROU_SplitBet(\d+)And(\d+)$/);
    if (split) return [Number(split[1]), Number(split[2])];

    // --- Street, Square, Line ---
    if (code.startsWith("ROU_StreetBet") || code.startsWith("ROU_SquareBet") || code.startsWith("ROU_LineBet")) {
      let nums = parseMultiNumbers(code);
      if (code.startsWith("ROU_StreetBet") && nums.length !== 3) console.warn("StreetBet should be 3 numbers:", code, nums);
      if (code.startsWith("ROU_SquareBet") && nums.length !== 4) console.warn("SquareBet should be 4 numbers:", code, nums);
      if (code.startsWith("ROU_LineBet") && nums.length !== 6) console.warn("LineBet should be 6 numbers:", code, nums);
      return nums;
    }

    if (code === "ROU_Red") return RED;
    if (code === "ROU_Black") return BLACK;
    if (code === "ROU_Odd") return ODD;
    if (code === "ROU_Even") return EVEN;

    return [];
  }

  // --- Calculate totals & coverage ---
  let totalStake = 0, totalPayout = 0;
  let coveredSet = new Set();

  const betRows = bets.map(b => {
    const numbers = getCoveredNumbers(b.code);
    numbers.forEach(n => coveredSet.add(n));
    totalStake += Number(b.stake) || 0;
    totalPayout += Number(b.payout) || 0;
    return `<tr>
      <td>${b.code}</td>
      <td>${b.stake}</td>
      <td>${b.payout}</td>
      <td>${numbers.length ? numbers.join(", ") : "-"}</td>
      <td>${b.payout > 0 ? '<span class="badge badge-win">Win</span>' : ''}</td>
    </tr>`;
  }).join("");

  const TOTAL = 37;
  const allNumbers = Array.from({ length: TOTAL }, (_, i) => i);
  const covered = [...coveredSet];
  const uncovered = allNumbers.filter(n => !coveredSet.has(n));
  const coveredPercent = (covered.length / TOTAL) * 100;
  const net = (totalPayout - totalStake).toFixed(2);
  const status = coveredPercent >= 85 ? "ARB" : "Not ARB";

  // --- Badge ---
  badge.className = "status-badge " + (status === "ARB" ? "status-arb" : "status-notarb");
  badge.textContent = `${status} (${coveredPercent.toFixed(2)}%)`;

  // --- Coverage tables ---
  const coveredRows = covered.map(n => `<tr><td>${n}</td><td><span class="badge badge-covered">Covered</span></td></tr>`).join("");
  const uncoveredRows = uncovered.map(n => `<tr><td>${n}</td><td><span class="badge badge-uncovered">Uncovered</span></td></tr>`).join("");

  // --- Output ---
  result.innerHTML = `
    <div class="section"><h3>üé≤ Bets Table</h3>
      <table class="table">
        <tr>
          <th>Bet Code</th>
          <th>Stake</th>
          <th>Payout</th>
          <th>Numbers Covered</th>
          <th>Winning?</th>
        </tr>
        ${betRows || `<tr><td colspan="5">No bets placed</td></tr>`}
        <tr>
          <th>Total</th>
          <td>${totalStake}</td>
          <td>${totalPayout}</td>
          <td>-</td>
          <td>Net: ${net}</td>
        </tr>
      </table>
    </div>

    <div class="section"><h3>üî¥ Covered Numbers (${covered.length}/${TOTAL})</h3>
      <table class="table">
        <tr><th>Number</th><th>Status</th></tr>
        ${coveredRows}
      </table>
    </div>

    <div class="section"><h3>‚ö†Ô∏è Uncovered Numbers (${uncovered.length}/${TOTAL})</h3>
      <table class="table">
        <tr><th>Number</th><th>Status</th></tr>
        ${uncoveredRows}
      </table>
    </div>
  `;
}







  


// sic bo
// I FUCKING HATE THIIIIISSSSS!!!!!!!! i enslave clanker to do this shitttt
if (game === "sicbo") {
  const boardOptions = new Set([
    "SicBo_Small","SicBo_Big","SicBo_Odd","SicBo_Even",
    "SicBo_Total4","SicBo_Total5","SicBo_Total6","SicBo_Total7","SicBo_Total8","SicBo_Total9","SicBo_Total10",
    "SicBo_Total11","SicBo_Total12","SicBo_Total13","SicBo_Total14","SicBo_Total15","SicBo_Total16","SicBo_Total17",
    "SicBo_One","SicBo_Two","SicBo_Three","SicBo_Four","SicBo_Five","SicBo_Six",
    "SicBo_Double1","SicBo_Double2","SicBo_Double3","SicBo_Double4","SicBo_Double5","SicBo_Double6",
    "SicBo_Triple1","SicBo_Triple2","SicBo_Triple3","SicBo_Triple4","SicBo_Triple5","SicBo_Triple6",
    "SicBo_AnyTriple",
    "SicBo_Combo1And2","SicBo_Combo1And3","SicBo_Combo1And4","SicBo_Combo1And5","SicBo_Combo1And6",
    "SicBo_Combo2And3","SicBo_Combo2And4","SicBo_Combo2And5","SicBo_Combo2And6",
    "SicBo_Combo3And4","SicBo_Combo3And5","SicBo_Combo3And6",
    "SicBo_Combo4And5","SicBo_Combo4And6",
    "SicBo_Combo5And6","SicBo_Triple"
  ]);

  try {
    const data = JSON.parse(jsonText);
    const betsUsed = data.filter(b => boardOptions.has(b.code));
    const uniqueBets = [...new Set(betsUsed.map(b => b.code))];

    const coveragePercent = (uniqueBets.length / boardOptions.size) * 100;
    const isArb = coveragePercent >= 85;
    const unusedBets = [...boardOptions].filter(b => !uniqueBets.includes(b));

    const totalStake = betsUsed.reduce((sum,b) => sum + Number(b.stake||0),0);
    const totalPayout = betsUsed.reduce((sum,b) => sum + Number(b.payout||0),0);
    const net = (totalPayout - totalStake).toFixed(2);

    const betDescriptions = {
      SicBo_Small: "Small Numbers (4-10)", SicBo_Big: "Big Numbers (11-17)",
      SicBo_Odd: "Odd Sums", SicBo_Even: "Even Sums",
      SicBo_Total4: "Total 4", SicBo_Total5: "Total 5", SicBo_Total6: "Total 6", SicBo_Total7: "Total 7",
      SicBo_Total8: "Total 8", SicBo_Total9: "Total 9", SicBo_Total10: "Total 10",
      SicBo_Total11: "Total 11", SicBo_Total12: "Total 12", SicBo_Total13: "Total 13", SicBo_Total14: "Total 14",
      SicBo_Total15: "Total 15", SicBo_Total16: "Total 16", SicBo_Total17: "Total 17",
      SicBo_One: "Contains 1", SicBo_Two: "Contains 2", SicBo_Three: "Contains 3",
      SicBo_Four: "Contains 4", SicBo_Five: "Contains 5", SicBo_Six: "Contains 6",
      SicBo_Double1: "Double 1", SicBo_Double2: "Double 2", SicBo_Double3: "Double 3",
      SicBo_Double4: "Double 4", SicBo_Double5: "Double 5", SicBo_Double6: "Double 6",
      SicBo_Triple1: "Triple 1", SicBo_Triple2: "Triple 2", SicBo_Triple3: "Triple 3",
      SicBo_Triple4: "Triple 4", SicBo_Triple5: "Triple 5", SicBo_Triple6: "Triple 6",
      SicBo_AnyTriple: "Any Triple",
      SicBo_Combo1And2: "Combo 1 & 2", SicBo_Combo1And3: "Combo 1 & 3", SicBo_Combo1And4: "Combo 1 & 4",
      SicBo_Combo1And5: "Combo 1 & 5", SicBo_Combo1And6: "Combo 1 & 6",
      SicBo_Combo2And3: "Combo 2 & 3", SicBo_Combo2And4: "Combo 2 & 4", SicBo_Combo2And5: "Combo 2 & 5",
      SicBo_Combo2And6: "Combo 2 & 6",
      SicBo_Combo3And4: "Combo 3 & 4", SicBo_Combo3And5: "Combo 3 & 5", SicBo_Combo3And6: "Combo 3 & 6",
      SicBo_Combo4And5: "Combo 4 & 5", SicBo_Combo4And6: "Combo 4 & 6", SicBo_Combo5And6: "Combo 5 & 6",
      SicBo_Triple: "Any Triple"
    };

    function getSicBoCoveredDice(betCode) {
      const outcomes = new Set();
      if (["SicBo_Small","SicBo_Big","SicBo_Odd","SicBo_Even"].includes(betCode)) {
        for (let sum=4; sum<=17; sum++) {
          if(betCode==="SicBo_Small" && sum>=4 && sum<=10) outcomes.add(sum.toString());
          if(betCode==="SicBo_Big" && sum>=11 && sum<=17) outcomes.add(sum.toString());
          if(betCode==="SicBo_Odd" && sum%2===1) outcomes.add(sum.toString());
          if(betCode==="SicBo_Even" && sum%2===0) outcomes.add(sum.toString());
        }
        return Array.from(outcomes);
      }
      for (let d1=1; d1<=6; d1++) {
        for (let d2=1; d2<=6; d2++) {
          for (let d3=1; d3<=6; d3++) {
            const dice = [d1,d2,d3];
            const sum = d1+d2+d3;
            const diceStr = dice.join(",");
            switch(betCode) {
              case "SicBo_Total4": if(sum===4) outcomes.add(diceStr); break;
              case "SicBo_Total5": if(sum===5) outcomes.add(diceStr); break;
              case "SicBo_Total6": if(sum===6) outcomes.add(diceStr); break;
              case "SicBo_Total7": if(sum===7) outcomes.add(diceStr); break;
              case "SicBo_Total8": if(sum===8) outcomes.add(diceStr); break;
              case "SicBo_Total9": if(sum===9) outcomes.add(diceStr); break;
              case "SicBo_Total10": if(sum===10) outcomes.add(diceStr); break;
              case "SicBo_Total11": if(sum===11) outcomes.add(diceStr); break;
              case "SicBo_Total12": if(sum===12) outcomes.add(diceStr); break;
              case "SicBo_Total13": if(sum===13) outcomes.add(diceStr); break;
              case "SicBo_Total14": if(sum===14) outcomes.add(diceStr); break;
              case "SicBo_Total15": if(sum===15) outcomes.add(diceStr); break;
              case "SicBo_Total16": if(sum===16) outcomes.add(diceStr); break;
              case "SicBo_Total17": if(sum===17) outcomes.add(diceStr); break;
              case "SicBo_One": if(dice.includes(1)) outcomes.add(diceStr); break;
              case "SicBo_Two": if(dice.includes(2)) outcomes.add(diceStr); break;
              case "SicBo_Three": if(dice.includes(3)) outcomes.add(diceStr); break;
              case "SicBo_Four": if(dice.includes(4)) outcomes.add(diceStr); break;
              case "SicBo_Five": if(dice.includes(5)) outcomes.add(diceStr); break;
              case "SicBo_Six": if(dice.includes(6)) outcomes.add(diceStr); break;
              case "SicBo_Double1": if([d1,d2,d3].filter(x=>x===1).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Double2": if([d1,d2,d3].filter(x=>x===2).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Double3": if([d1,d2,d3].filter(x=>x===3).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Double4": if([d1,d2,d3].filter(x=>x===4).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Double5": if([d1,d2,d3].filter(x=>x===5).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Double6": if([d1,d2,d3].filter(x=>x===6).length>=2) outcomes.add(diceStr); break;
              case "SicBo_Triple": if(d1 === d2 && d2 === d3) outcomes.add(d1+","+d2+","+d3); break;
              case "SicBo_Triple1": if(d1===1&&d2===1&&d3===1) outcomes.add(diceStr); break;
              case "SicBo_Triple2": if(d1===2&&d2===2&&d3===2) outcomes.add(diceStr); break;
              case "SicBo_Triple3": if(d1===3&&d2===3&&d3===3) outcomes.add(diceStr); break;
              case "SicBo_Triple4": if(d1===4&&d2===4&&d3===4) outcomes.add(diceStr); break;
              case "SicBo_Triple5": if(d1===5&&d2===5&&d3===5) outcomes.add(diceStr); break;
              case "SicBo_Triple6": if(d1===6&&d2===6&&d3===6) outcomes.add(diceStr); break;
              case "SicBo_AnyTriple": if(d1===d2&&d2===d3) outcomes.add(diceStr); break;
              default:
                if(betCode.startsWith("SicBo_Combo")) {
                  const nums = betCode.match(/\d/g).map(Number);
                  if(nums.every(n=>dice.includes(n))) outcomes.add(diceStr);
                }
            }
          }
        }
      }
      return Array.from(outcomes);
    }

    // ---------- Outcome Coverage ----------
    const allOutcomes = new Set();
    uniqueBets.forEach(betCode => getSicBoCoveredDice(betCode).forEach(x=>allOutcomes.add(x)));
    const totalOutcomes = 216;
    const coveredOutcomes = allOutcomes.size;
    const outcomeCoveragePercent = (coveredOutcomes / totalOutcomes) * 100;
    const isOutcomeArb = outcomeCoveragePercent >= 85;

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Sic Bo Bets Table</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Stake</th><th>Payout</th><th>Winning?</th></tr>
          ${betsUsed.map(b => `<tr>
            <td>${b.code}</td>
            <td>${b.stake}</td>
            <td>${b.payout}</td>
            <td>${b.payout>0?'<span class="badge badge-win">Win</span>':'<span class="badge badge-loss">Lost</span>'}</td>
          </tr>`).join("")}
          <tr>
            <th>Total</th>
            <td>${totalStake}</td>
            <td>${totalPayout}</td>
            <td>Net: ${net}</td>
          </tr>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Bets (${uniqueBets.length}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Description</th><th>Status</th><th>Outcome Count</th><th>Possible Outcomes</th></tr>
          ${uniqueBets.map(b=>{
            const outcomes = [...new Set(getSicBoCoveredDice(b))];
            outcomes.sort((a,b)=>{
              const aNums = a.split(",").map(Number);
              const bNums = b.split(",").map(Number);
              for(let i=0;i<3;i++){if((aNums[i]||0)!==(bNums[i]||0)) return (aNums[i]||0)-(bNums[i]||0);}
              return 0;
            });
            const bet = betsUsed.find(x=>x.code===b);
            const status = bet && bet.payout>0 ? '<span class="badge badge-win">Win</span>' : '<span class="badge badge-covered">Covered</span>';
            return `<tr>
              <td>${b}</td>
              <td>${betDescriptions[b]||"-"}</td>
              <td>${status}</td>
              <td>${outcomes.length}</td>
              <td>${outcomes.join(" | ")}</td>
            </tr>`;
          }).join("")}
        </table>
      </div>

      <div class="section"><h3>‚ö†Ô∏è Uncovered Bets (${unusedBets.length}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Status</th></tr>
          ${unusedBets.map(b=>`<tr><td>${b}</td><td><span class="badge badge-uncovered">Uncovered</span></td></tr>`).join("")}
        </table>
      </div>

      <div class="section">
        <h3>üìä Coverage Summary</h3>
        <table class="table">
          <tr><th>Metric</th><th>Value</th></tr>
          <tr><td>Board Coverage</td><td>${coveragePercent.toFixed(2)}%</td></tr>
          <tr><td>Outcome Coverage</td><td>${outcomeCoveragePercent.toFixed(2)}%</td></tr>
          <tr><td>Covered Outcomes</td><td>${coveredOutcomes} / ${totalOutcomes}</td></tr>
        </table>
      </div>
    `;

    if(isArb || isOutcomeArb){
      badge.className = "status-badge status-arb";
      badge.textContent = `ARB ‚úÖ (Board: ${coveragePercent.toFixed(2)}%, Outcomes: ${outcomeCoveragePercent.toFixed(2)}%)`;
    } else {
      badge.className = "status-badge status-notarb";
      badge.textContent = `NOT ARB ‚ùå (Board: ${coveragePercent.toFixed(2)}%, Outcomes: ${outcomeCoveragePercent.toFixed(2)}%)`;
    }

  } catch(err){
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Sic Bo JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}








// ----------LIGHTNING DICE ANALYZER  ----------
if (game === "lightningdice") {
  try {
    const dataArray = Array.isArray(JSON.parse(jsonText)) 
      ? JSON.parse(jsonText) 
      : (JSON.parse(jsonText).bets || []);

    // ---------- Board Options ----------
    const boardOptions = new Set([
      "DICE_Low","DICE_High",
      "DICE_Total3","DICE_Total4","DICE_Total5","DICE_Total6","DICE_Total7","DICE_Total8","DICE_Total9",
      "DICE_Total10","DICE_Total11","DICE_Total12","DICE_Total13","DICE_Total14","DICE_Total15","DICE_Total16","DICE_Total17","DICE_Total18",
      "DICE_AnyDouble","DICE_AnyTriple"
    ]);

    // ---------- Bets ----------
    const betsUsed = dataArray.filter(b => b && typeof b.code === 'string' && boardOptions.has(b.code));
    const uniqueBets = [...new Set(betsUsed.map(b => b.code))];
    const unusedBets = [...boardOptions].filter(b => !uniqueBets.includes(b));

    // ---------- Coverage ----------
    const coveredOutcomes = new Set();
    uniqueBets.forEach(code => getLightningCoveredDice(code).forEach(o => coveredOutcomes.add(o)));
    const coveragePercent = (coveredOutcomes.size / 216) * 100;
    const isArb = coveragePercent >= 85;

    // ---------- Totals ----------
    const totalStake = betsUsed.reduce((s,b)=> s+Number(b.stake||0), 0);
    const totalPayout = betsUsed.reduce((s,b)=> s+Number(b.payout||0), 0);
    const net = (totalPayout - totalStake).toFixed(2);

    // ---------- Bet Descriptions ----------
    const betDescriptions = {
      DICE_Low: "Low (3‚Äì10)",
      DICE_High: "High (11‚Äì18)",
      DICE_AnyDouble: "Any Double (exactly two equal)",
      DICE_AnyTriple: "Any Triple (three equal)"
    };
    for (let t=3;t<=18;t++) betDescriptions[`DICE_Total${t}`] = `Total ${t}`;

    // ---------- CSS for Badges ----------
    const style = document.createElement('style');
    style.textContent = `
      .badge { padding: 2px 6px; border-radius: 4px; color: white; font-weight: bold; }
      .win { background-color: orange; }
      .loss { background-color: red; }
      .covered { background-color: green; }
      .uncovered { background-color: red; }
    `;
    document.head.appendChild(style);

    // ---------- Render Table ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Lightning Dice Bets Table</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Description</th><th>Stake</th><th>Payout</th><th>Result</th></tr>
          ${betsUsed.map(b => `<tr>
            <td>${b.code}</td>
            <td>${betDescriptions[b.code]||'-'}</td>
            <td>${Number(b.stake||0)}</td>
            <td>${Number(b.payout||0)}</td>
            <td>${Number(b.payout||0)>0?'<span class="badge win">Win</span>':'<span class="badge loss">Lost</span>'}</td>
          </tr>`).join('')}
          <tr><th>Total</th><td></td><td>${totalStake}</td><td>${totalPayout}</td><td>Net: ${net}</td></tr>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Bets (${uniqueBets.length}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Status</th><th>Outcome Count</th><th>Possible Outcomes</th></tr>
          ${uniqueBets.map((code,idx)=>{
            const bet = betsUsed.find(x=>x.code===code);
            const status = bet && Number(bet.payout||0)>0 ? '<span class="badge win">Win</span>' : '<span class="badge covered">Covered</span>';
            const combos = getLightningCoveredDice(code);
            const short = combos.slice(0,60).join(' | ');
            const more = combos.length>60;
            const id = `combos-${idx}`;
            return `<tr>
              <td>${code}</td>
              <td>${status}</td>
              <td>${combos.length}</td>
              <td>
                <div id="${id}-short" class="combos">${short}${more?' | ...':''}</div>
                ${more?`<div id="${id}-full" class="combos" style="display:none">${combos.join(' | ')}</div>
                         <div><a class="toggle" data-target="${id}">Show more</a></div>`:''}
              </td>
            </tr>`;
          }).join('')}
        </table>
      </div>

      <div class="section"><h3>‚ö†Ô∏è Uncovered Bets (${unusedBets.length}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Status</th></tr>
          ${unusedBets.map(b=>`<tr><td>${b}</td><td><span class="badge uncovered">Uncovered</span></td></tr>`).join('')}
        </table>
      </div>

      <div class="section"><p class="muted">Covered outcomes: ${coveredOutcomes.size} of 216</p>
        <p class="muted">Coverage: ${coveragePercent.toFixed(2)}%</p></div>
    `;

    // update ARB badge
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

    // toggle "show more" combos
    document.querySelectorAll('a.toggle').forEach(a=>{
      a.addEventListener('click',e=>{
        e.preventDefault();
        const id = a.dataset.target;
        const shortEl = document.getElementById(id+'-short');
        const fullEl = document.getElementById(id+'-full');
        if(fullEl.style.display==='none'){fullEl.style.display='block';shortEl.style.display='none';a.textContent='Show less';}
        else{fullEl.style.display='none';shortEl.style.display='block';a.textContent='Show more';}
      });
    });

    // ---------- Outcome Coverage Function ----------
    function getLightningCoveredDice(betCode){
      const outcomes=[];
      for(let d1=1;d1<=6;d1++){
        for(let d2=1;d2<=6;d2++){
          for(let d3=1;d3<=6;d3++){
            const sum=d1+d2+d3;
            const uniqueCount = new Set([d1,d2,d3]).size;
            const isDoubleExact = uniqueCount===2;
            const isTriple = uniqueCount===1;
            if(betCode==="DICE_Low" && sum>=3 && sum<=10) outcomes.push(`${d1},${d2},${d3}`);
            else if(betCode==="DICE_High" && sum>=11 && sum<=18) outcomes.push(`${d1},${d2},${d3}`);
            else if(betCode==="DICE_AnyDouble" && isDoubleExact) outcomes.push(`${d1},${d2},${d3}`);
            else if(betCode==="DICE_AnyTriple" && isTriple) outcomes.push(`${d1},${d2},${d3}`);
            else if(betCode.startsWith("DICE_Total")){
              const t=parseInt(betCode.replace("DICE_Total",""),10);
              if(sum===t) outcomes.push(`${d1},${d2},${d3}`);
            }
          }
        }
      }
      return outcomes;
    }

  } catch(err){
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Lightning Dice JSON: ${err.message}</p>`;
    badge.className="status-badge status-warning";
    badge.textContent="Error";
  }
}







// ---------- Lightning Sic Bo FUCK THIS SHIIIIT!!! NOT WOWOORKINGZZ ----------
if (game === "lightningsicbo") {
  try {
    const data = JSON.parse(jsonText);

    // Separate normal bets and Lightning Fee bets
    const normalBets = data.filter(b => !b.code.includes('_Fee'));
    const feeBets = data.filter(b => b.code.includes('_Fee'));

    // possible board options
    const boardOptions = new Set([
      "SicBo_Small","SicBo_Big","SicBo_Odd","SicBo_Even",
      "SicBo_Total4","SicBo_Total5","SicBo_Total6","SicBo_Total7","SicBo_Total8","SicBo_Total9","SicBo_Total10",
      "SicBo_Total11","SicBo_Total12","SicBo_Total13","SicBo_Total14","SicBo_Total15","SicBo_Total16","SicBo_Total17",
      "SicBo_One","SicBo_Two","SicBo_Three","SicBo_Four","SicBo_Five","SicBo_Six",
      "SicBo_Double1","SicBo_Double2","SicBo_Double3","SicBo_Double4","SicBo_Double5","SicBo_Double6",
      "SicBo_Triple1","SicBo_Triple2","SicBo_Triple3","SicBo_Triple4","SicBo_Triple5","SicBo_Triple6",
      "SicBo_AnyTriple",
      "SicBo_Combo1And2","SicBo_Combo1And3","SicBo_Combo1And4","SicBo_Combo1And5","SicBo_Combo1And6",
      "SicBo_Combo2And3","SicBo_Combo2And4","SicBo_Combo2And5","SicBo_Combo2And6",
      "SicBo_Combo3And4","SicBo_Combo3And5","SicBo_Combo3And6",
      "SicBo_Combo4And5","SicBo_Combo4And6",
      "SicBo_Combo5And6","SicBo_Triple"
    ]);

    let totalStake = 0;
    let totalFee = 0;
    let totalPayout = 0;
    const coveredBets = new Set();

    normalBets.forEach(b => {
      totalStake += Number(b.stake || 0);
      totalPayout += Number(b.payout || 0);
      if (boardOptions.has(b.code)) coveredBets.add(b.code);
    });

    feeBets.forEach(f => {
      totalFee += Number(f.stake || 0);
    });

    const combinedStake = totalStake + totalFee;
    const coveragePercent = (coveredBets.size / boardOptions.size) * 100;
    const isArb = coveragePercent >= 85;

    // to get covered outcomes to display blah blah idk
    function getLightningSicBoCoveredDice(betCode) {
      const outcomes = [];
      for (let d1=1; d1<=6; d1++) {
        for (let d2=1; d2<=6; d2++) {
          for (let d3=1; d3<=6; d3++) {
            const sum = d1+d2+d3;
            const dice = [d1,d2,d3];
            switch(betCode) {
              case "SicBo_Small": if(sum>=4 && sum<=10) outcomes.push(dice.join(",")); break;
              case "SicBo_Big": if(sum>=11 && sum<=17) outcomes.push(dice.join(",")); break;
              case "SicBo_Odd": if(sum%2===1) outcomes.push(dice.join(",")); break;
              case "SicBo_Even": if(sum%2===0) outcomes.push(dice.join(",")); break;
              case "SicBo_Total4": if(sum===4) outcomes.push(dice.join(",")); break;
              case "SicBo_Total5": if(sum===5) outcomes.push(dice.join(",")); break;
              case "SicBo_Total6": if(sum===6) outcomes.push(dice.join(",")); break;
              case "SicBo_Total7": if(sum===7) outcomes.push(dice.join(",")); break;
              case "SicBo_Total8": if(sum===8) outcomes.push(dice.join(",")); break;
              case "SicBo_Total9": if(sum===9) outcomes.push(dice.join(",")); break;
              case "SicBo_Total10": if(sum===10) outcomes.push(dice.join(",")); break;
              case "SicBo_Total11": if(sum===11) outcomes.push(dice.join(",")); break;
              case "SicBo_Total12": if(sum===12) outcomes.push(dice.join(",")); break;
              case "SicBo_Total13": if(sum===13) outcomes.push(dice.join(",")); break;
              case "SicBo_Total14": if(sum===14) outcomes.push(dice.join(",")); break;
              case "SicBo_Total15": if(sum===15) outcomes.push(dice.join(",")); break;
              case "SicBo_Total16": if(sum===16) outcomes.push(dice.join(",")); break;
              case "SicBo_Total17": if(sum===17) outcomes.push(dice.join(",")); break;
              case "SicBo_One": if(dice.includes(1)) outcomes.push(dice.join(",")); break;
              case "SicBo_Two": if(dice.includes(2)) outcomes.push(dice.join(",")); break;
              case "SicBo_Three": if(dice.includes(3)) outcomes.push(dice.join(",")); break;
              case "SicBo_Four": if(dice.includes(4)) outcomes.push(dice.join(",")); break;
              case "SicBo_Five": if(dice.includes(5)) outcomes.push(dice.join(",")); break;
              case "SicBo_Six": if(dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Double1": if([d1,d2,d3].filter(x=>x===1).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Double2": if([d1,d2,d3].filter(x=>x===2).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Double3": if([d1,d2,d3].filter(x=>x===3).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Double4": if([d1,d2,d3].filter(x=>x===4).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Double5": if([d1,d2,d3].filter(x=>x===5).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Double6": if([d1,d2,d3].filter(x=>x===6).length>=2) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple1": if(d1===1&&d2===1&&d3===1) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple2": if(d1===2&&d2===2&&d3===2) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple3": if(d1===3&&d2===3&&d3===3) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple4": if(d1===4&&d2===4&&d3===4) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple5": if(d1===5&&d2===5&&d3===5) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple6": if(d1===6&&d2===6&&d3===6) outcomes.push(dice.join(",")); break;
              case "SicBo_AnyTriple": if(d1===d2 && d2===d3) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo1And2": if(dice.includes(1)&&dice.includes(2)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo1And3": if(dice.includes(1)&&dice.includes(3)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo1And4": if(dice.includes(1)&&dice.includes(4)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo1And5": if(dice.includes(1)&&dice.includes(5)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo1And6": if(dice.includes(1)&&dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo2And3": if(dice.includes(2)&&dice.includes(3)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo2And4": if(dice.includes(2)&&dice.includes(4)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo2And5": if(dice.includes(2)&&dice.includes(5)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo2And6": if(dice.includes(2)&&dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo3And4": if(dice.includes(3)&&dice.includes(4)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo3And5": if(dice.includes(3)&&dice.includes(5)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo3And6": if(dice.includes(3)&&dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo4And5": if(dice.includes(4)&&dice.includes(5)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo4And6": if(dice.includes(4)&&dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Combo5And6": if(dice.includes(5)&&dice.includes(6)) outcomes.push(dice.join(",")); break;
              case "SicBo_Triple": if(d1===d2 && d2===d3) outcomes.push(dice.join(",")); break;
            }
          }
        }
      }
      return [...new Set(outcomes)];
    }

    // ---------- Render Lightning Sic Bo Tables ----------
    result.innerHTML = `
      <div class="section"><h3>‚ö° Lightning Sic Bo Bets Table</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Stake</th><th>Payout</th><th>Winning?</th></tr>
          ${normalBets.map(b => `<tr>
            <td>${b.code}</td>
            <td>${b.stake}</td>
            <td>${b.payout}</td>
            <td>${b.payout>0?'<span class="badge badge-win">Win</span>':''}</td>
          </tr>`).join("")}
          <tr>
            <th>Total</th>
            <td>${totalStake}</td>
            <td>${totalPayout}</td>
            <td>Net: ${(totalPayout-totalStake).toFixed(2)}</td>
          </tr>
          <tr>
            <th>Fee Total</th>
            <td colspan="3">${totalFee}</td>
          </tr>
          <tr>
            <th>Combined Stake</th>
            <td colspan="3">${combinedStake}</td>
          </tr>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Bets (${coveredBets.size}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Status</th><th>Outcome (Count)</th><th>Possible Outcomes</th></tr>
          ${[...coveredBets].map(b => {
            const outcomes = getLightningSicBoCoveredDice(b);
            return `<tr>
              <td>${b}</td>
              <td><span class="badge badge-covered">Covered</span></td>
              <td>${outcomes.length}</td>
              <td>${outcomes.join(" | ")}</td>
            </tr>`;
          }).join("")}
        </table>
      </div>

      <div class="section"><h3>‚ö†Ô∏è Uncovered Bets (${boardOptions.size - coveredBets.size}/${boardOptions.size})</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Status</th></tr>
          ${[...boardOptions].filter(b => !coveredBets.has(b)).map(b => `<tr><td>${b}</td><td><span class="badge badge-uncovered">Uncovered</span></td></tr>`).join("")}
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Lightning Sic Bo JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- 7 Up 7 Down ----------
function sevenUPsevenDOWN(jsonText, result, badge) {
  try {
    const POSSIBLE_NUMBERS = ["2","3","4","5","6","7","8","9","10","11"];
    const betSummary = {};
    let totalStake = 0, totalPayout = 0;

    const data = JSON.parse(jsonText);
    const bets = Array.isArray(data) ? data : [data];

    for (const item of bets) {
      if (!item.betType) continue;

      const parts = item.betType.split(",").map(s => s.trim());
      const totalProfit = parseFloat(item.profit) || 0;
      const totalStakeForBet = parts.reduce((acc, p) => {
        const m = p.match(/^sud-\w+\s*:\s*(\d+(\.\d+)?)/);
        return acc + (m ? parseFloat(m[1]) : 0);
      }, 0);

      for (const part of parts) {
        const match = part.match(/^sud-(\w+)\s*:\s*(\d+(\.\d+)?)/i);
        if (!match) continue;

        let betName = match[1].toLowerCase();
        const stake = parseFloat(match[2]) || 0;

        const numMap = {
          "two":"2","three":"3","four":"4","five":"5","six":"6",
          "seven":"7","eight":"8","nine":"9","ten":"10","eleven":"11"
        };
        if (numMap[betName]) betName = numMap[betName];

        // Determine numbers covered
        let numbersCovered = [];
        if (betName === "up") numbersCovered = ["8","9","10","11"];
        else if (betName === "down") numbersCovered = ["2","3","4","5","6"];
        else numbersCovered = [betName];

        // Proportional profit per bet
        const profitShare = (stake / totalStakeForBet) * totalProfit;
        const payoutPerNumber = (stake + profitShare) / numbersCovered.length;
        const stakePerNumber = stake / numbersCovered.length;

        numbersCovered.forEach(num => {
          if (!betSummary[num]) betSummary[num] = { stake: 0, payout: 0 };
          betSummary[num].stake += stakePerNumber;
          betSummary[num].payout += payoutPerNumber;
        });

        totalStake += stake;
        totalPayout += stake + profitShare;
      }
    }

    const covered = POSSIBLE_NUMBERS.filter(n => betSummary[n]);
    const uncovered = POSSIBLE_NUMBERS.filter(n => !betSummary[n]);
    const coveragePercent = (covered.length / POSSIBLE_NUMBERS.length) * 100;
    const isArb = coveragePercent >= 85;

    // Render Result
    result.innerHTML = `
      <div class="section">
        <h3>üé≤ 7 Up 7 Down Bets Table</h3>
        <table class="table">
          <thead>
            <tr><th>Number</th><th>Stake</th><th>Payout</th><th>Status</th></tr>
          </thead>
          <tbody>
            ${POSSIBLE_NUMBERS.map(num => {
              const bet = betSummary[num];
              let status = '<span class="badge badge-notbet">No Wager</span>';
              if (bet) status = bet.payout > 0 ? '<span class="badge badge-win" style="color:black;">Win</span>'
                                               : '<span class="badge badge-lost" style="color:red;">Lost</span>';
              return `
                <tr>
                  <td>${num}</td>
                  <td>${bet ? bet.stake.toFixed(2) : "0"}</td>
                  <td>${bet ? bet.payout.toFixed(2) : "0"}</td>
                  <td>${status}</td>
                </tr>`;
            }).join("")}
            <tr>
              <th>Total</th>
              <td>${totalStake.toFixed(2)}</td>
              <td>${totalPayout.toFixed(2)}</td>
              <td>Net: ${(totalPayout - totalStake).toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section">
        <h3>üü¢ Covered Numbers (${covered.length}/${POSSIBLE_NUMBERS.length})</h3>
        <table class="table">
          <thead><tr><th>Number</th><th>Stake</th><th>Payout</th></tr></thead>
          <tbody>
            ${covered.map(num => `
              <tr>
                <td>${num}</td>
                <td>${betSummary[num].stake.toFixed(2)}</td>
                <td>${betSummary[num].payout.toFixed(2)}</td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>

      <div class="section">
        <h3>üö´ Not Covered Numbers (${uncovered.length}/${POSSIBLE_NUMBERS.length})</h3>
        <table class="table">
          <thead><tr><th>Number</th></tr></thead>
          <tbody>
            ${uncovered.map(num => `<tr><td>${num}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing 7 Up 7 Down JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}



// ---------- Call when selected ----------
if (game === "sevenupsevendown") {
  sevenUPsevenDOWN(jsonText, result, badge);
}










// ---------- Fan Tan Coverage ----------
function analyzeFanTanCoverage(jsonText, result, badge) {
  try {
    const data = JSON.parse(jsonText);
    const allOutcomes = ["1", "2", "3", "4"];
    const coveredOutcomes = new Set();
    const betCodes = Array.from(new Set(data.map(b => b.code).filter(Boolean)));

    const addOutcomesForBet = (code) => {
      if (!code) return;

      if (code.match(/^FT_(\d)$/)) {
        // Single number bet
        coveredOutcomes.add(code.split("_")[1]);

      } else if (code.startsWith("FT_Kwok_")) {
        // Kwok bet (covers 2 outcomes)
        const match = code.match(/FT_Kwok_(\d)_(\d)/);
        if (match) {
          coveredOutcomes.add(match[1]);
          coveredOutcomes.add(match[2]);
        }

      } else if (code.startsWith("FT_Ssh_")) {
        // SSH bet (covers 3 outcomes)
        const match = code.match(/FT_Ssh_(\d)_(\d)_(\d)/);
        if (match) {
          coveredOutcomes.add(match[1]);
          coveredOutcomes.add(match[2]);
          coveredOutcomes.add(match[3]);
        }

      } else if (code === "FT_Big") {
        coveredOutcomes.add("3");
        coveredOutcomes.add("4");

      } else if (code === "FT_Small") {
        coveredOutcomes.add("1");
        coveredOutcomes.add("2");

      } else if (code === "FT_Odd") {
        coveredOutcomes.add("1");
        coveredOutcomes.add("3");

      } else if (code === "FT_Even") {
        coveredOutcomes.add("2");
        coveredOutcomes.add("4");
      }
    };

    for (const code of betCodes) addOutcomesForBet(code);

    const covered = Array.from(coveredOutcomes).sort();
    const notCovered = allOutcomes.filter(o => !coveredOutcomes.has(o));
    const coveragePercent = (covered.length / allOutcomes.length) * 100;
    const isArb = coveragePercent >= 85;

    // Map bets with stake, payout, net, and win badge
    const betDetails = data.map(b => ({
      code: b.code,
      stake: b.stake || 0,
      payout: b.payout || 0,
      net: ((b.payout || 0) - (b.stake || 0)).toFixed(2),
      winBadge: (b.payout || 0) > 0 ? '<span class="badge badge-win">Win</span>' : ''
    }));

    // Compute totals
    const totalStake = betDetails.reduce((sum, b) => sum + b.stake, 0);
    const totalPayout = betDetails.reduce((sum, b) => sum + b.payout, 0);
    const totalNet = (totalPayout - totalStake).toFixed(2);

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Fan Tan Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Bet Code</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Net</th>
              <th>Winning?</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.code}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td>${b.net}</td>
                <td>${b.winBadge}</td>
              </tr>
            `).join("")}
            <tr>
              <th>Total</th>
              <th>${totalStake}</th>
              <th>${totalPayout}</th>
              <th>${totalNet}</th>
              <th></th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Outcomes (${covered.length}/${allOutcomes.length})</h3>
        <table class="table">
          <thead><tr><th>Outcome</th></tr></thead>
          <tbody>
            ${covered.length ? covered.map(o => `<tr><td>${o}</td></tr>`).join("") : `<tr><td>None</td></tr>`}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üö´ Not Covered Outcomes (${notCovered.length}/${allOutcomes.length})</h3>
        <table class="table">
          <thead><tr><th>Outcome</th></tr></thead>
          <tbody>
            ${notCovered.length ? notCovered.map(o => `<tr><td>${o}</td></tr>`).join("") : `<tr><td>None</td></tr>`}
          </tbody>
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Fan Tan JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}
// calling fantan blub blub
if (game === "fantan") {
  analyzeFanTanCoverage(jsonText, result, badge);
}





// ---------- Number Matka Coverage ----------
function NumberMatkaBet(jsonText, result, badge) {
  try {
    if (typeof jsonText !== 'string') jsonText = JSON.stringify(jsonText);
    const data = JSON.parse(jsonText);
    const betString = data.betType || '';
    const entries = betString.split(',').map(e => e.trim());

    const HIGH_RANGE = { start: 500, end: 999 };
    const LOW_RANGE = { start: 0, end: 499 };
    let totalCoveredNumbers = new Set(); // remove duplicates
    let betDetails = [];
    let totalStake = 0;

    const totalProfit = parseFloat(data.profit || 0);

    // ---------- Parse bets ----------
    entries.forEach(entry => {
      const [code, stakeStr] = entry.split(':').map(s => s.trim());
      const stake = parseFloat(stakeStr) || 0;
      totalStake += stake;

      if (code === "tc-high") {
        for (let i = HIGH_RANGE.start; i <= HIGH_RANGE.end; i++) totalCoveredNumbers.add(i);
        betDetails.push({ type: "High Range", code, range: `${HIGH_RANGE.start}-${HIGH_RANGE.end}`, stake });
        return;
      }

      if (code === "tc-low") {
        for (let i = LOW_RANGE.start; i <= LOW_RANGE.end; i++) totalCoveredNumbers.add(i);
        betDetails.push({ type: "Low Range", code, range: `${LOW_RANGE.start}-${LOW_RANGE.end}`, stake });
        return;
      }

      if (code.startsWith("tc-one-number-")) {
        const num = parseInt(code.replace("tc-one-number-", ""));
        if (!isNaN(num) && num >= 0 && num <= 9) {
          totalCoveredNumbers.add(num);
          betDetails.push({ type: "One-digit", code, range: `${num}`, stake });
        }
      } else if (code.startsWith("tc-two-number-")) {
        const [start, end] = code.replace("tc-two-number-", "").split('-').map(Number);
        for (let i = start; i <= end; i++) totalCoveredNumbers.add(i);
        betDetails.push({ type: "Two-digit", code, range: `${start}-${end}`, stake });
      } else if (code.startsWith("tc-three-number-")) {
        const [start, end] = code.replace("tc-three-number-", "").split('-').map(Number);
        for (let i = start; i <= end; i++) totalCoveredNumbers.add(i);
        betDetails.push({ type: "Three-digit", code, range: `${start}-${end}`, stake });
      }
    });

    const totalNumbers = 1000;
    const coveragePercent = (totalCoveredNumbers.size / totalNumbers) * 100;
    const isArb = coveragePercent >= 85;

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Number Matka Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Type</th>
              <th>Code</th>
              <th>Range</th>
              <th>Stake</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.type}</td>
                <td>${b.code}</td>
                <td>${b.range}</td>
                <td>${b.stake}</td>
              </tr>
            `).join("")}
            <tr>
              <th colspan="3">Total</th>
              <th>${totalStake}</th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üìä Coverage Summary</h3>
        <table class="table">
          <tr><th>Covered Numbers</th><td>${totalCoveredNumbers.size}/1000</td></tr>
          <tr><th>Coverage %</th><td>${coveragePercent.toFixed(2)}%</td></tr>
          <tr><th>Total Stake</th><td>${totalStake}</td></tr>
          <tr><th>Total Profit</th><td>${totalProfit}</td></tr>
        </table>
      </div>
    `;

    // ---------- Update Badge ----------
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (e) {
    result.innerHTML = `<p>‚ö†Ô∏è Invalid JSON or format: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- call Number Matka ----------
if (game === "numbermatka") {
  NumberMatkaBet(jsonText, result, badge);
}





// ---------- Monopoly Big Baller Coverage ----------
function MonopolyBigBallerBet(jsonText, result, badge) {
  try {
    if (typeof jsonText !== 'string') {
      jsonText = JSON.stringify(jsonText);
    }

    const data = JSON.parse(jsonText);

    const validCodes = [
      "MBB_ChanceCard1",
      "MBB_ChanceCard2",
      "MBB_ChanceCard3",
      "MBB_ChanceCard4",
      "MBB_3Rolls",
      "MBB_5Rolls"
    ];

    const betDetails = [];
    let totalStake = 0, totalPayout = 0;

    data.forEach(bet => {
      const { code, stake = 0, payout = 0 } = bet;
      if (validCodes.includes(code)) {
        totalStake += stake;
        totalPayout += payout;
        betDetails.push({
          code,
          stake,
          payout,
          status: payout > 0 ? "‚úÖ Win" : "‚ùå Lost"
        });
      }
    });

    const coveredBets = betDetails.map(b => b.code);
    const uncoveredBets = validCodes.filter(c => !coveredBets.includes(c));

    const covered = coveredBets.length * 25; // each bet = 25 outcomes
    const maxOutcomes = 150;
    const coveragePercent = (covered / maxOutcomes) * 100;

    const isArb = coveragePercent >= 85;
    const net = (totalPayout - totalStake).toFixed(2);

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Monopoly Big Baller Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Code</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.length ? betDetails.map(b => `
              <tr class="${b.payout > 0 ? "win-row" : ""}">
                <td>${b.code}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td>${b.status}</td>
              </tr>
            `).join("") : "<tr><td colspan='4'>No Covered Bets</td></tr>"}
            <tr>
              <th colspan="3">Total Stake</th>
              <th>${totalStake}</th>
            </tr>
            <tr>
              <th colspan="3">Total Payout</th>
              <th>${totalPayout}</th>
            </tr>
            <tr>
              <th colspan="3">Net</th>
              <th>${net}</th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üìä Coverage Summary</h3>
        <table class="table">
          <tr><th>Covered Bets</th><td>${coveredBets.length}/${validCodes.length}</td></tr>
          <tr><th>Covered Outcomes</th><td>${covered}/${maxOutcomes}</td></tr>
          <tr><th>Coverage %</th><td>${coveragePercent.toFixed(2)}%</td></tr>
          <tr><th>Uncovered Bets</th><td>${uncoveredBets.join(", ") || "None"}</td></tr>
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (e) {
    result.innerHTML = `<p>‚ö†Ô∏è Invalid JSON or format: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- Monopoly ----------
if (game === "monopoly") {
  MonopolyBigBallerBet(jsonText, result, badge);
}



// ---------- Funky Time Coverage ----------
function EVOFunkyTimeCoverage(jsonString, result, badge) {
  try {
    const data = JSON.parse(jsonString);

    const validCodes = [
      "FNT_LetterA","FNT_LetterE","FNT_LetterF","FNT_LetterI","FNT_LetterK",
      "FNT_LetterL","FNT_LetterM","FNT_LetterN","FNT_LetterP","FNT_LetterT",
      "FNT_LetterU","FNT_LetterY",
      "FNT_Bar","FNT_StayinAlive","FNT_Disco","FNT_VipDisco"
    ];

    const normalizationMap = {
      "FNT_BAR": "FNT_Bar",
      "FNT_STAYINALIVE": "FNT_StayinAlive",
      "FNT_DISCO": "FNT_Disco",
      "FNT_VIPDISCO": "FNT_VipDisco"
    };

    const uniqueBets = new Set();
    const betDetails = [];
    let totalStake = 0, totalPayout = 0;
    const stakes = {};
    const payouts = {};

    for (const entry of data) {
      if (!entry.code) continue;
      let code = entry.code.toUpperCase().trim();
      code = normalizationMap[code] || entry.code.trim();
      if (validCodes.includes(code)) {
        uniqueBets.add(code);
        const stake = entry.stake || 0;
        const payout = entry.payout || 0;
        totalStake += stake;
        totalPayout += payout;
        stakes[code] = (stakes[code] || 0) + stake;
        payouts[code] = (payouts[code] || 0) + payout;
        betDetails.push({
          code,
          stake,
          payout,
          status: payout > 0 ? "WIN" : "LOSE"
        });
      }
    }

    const net = (totalPayout - totalStake).toFixed(2);
    const coveredList = Array.from(uniqueBets).sort();
    const uncoveredList = validCodes.filter(code => !uniqueBets.has(code)).sort();

    const coveragePercent = (coveredList.length / validCodes.length) * 100;
    const isArb = coveragePercent >= 85;

   // ---------- Styled ARB / Coverage Badge for Funky Time ----------
const arbBadgeHTML = `<div style="
    float: right;
    padding: 6px 14px;
    border-radius: 6px;
    font-weight: bold;
    font-size: 14px;
    color: white;
    background-color: ${isArb ? '#28a745' : '#dc3545'};
    border: 2px solid ${isArb ? '#28a745' : '#dc3545'};
    box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    text-align: center;
">
    ${isArb ? 'ARB ‚úÖ' : 'NOT ARB ‚ùå'} | ${coveragePercent.toFixed(2)}%
</div>`;


    badge.innerHTML = arbBadgeHTML;

    // ---------- Bets Table ----------
    let html = `<h2>üïπÔ∏è Funky Time Bets Table</h2>
      <table class="table" border="1" cellpadding="5" cellspacing="0" style="width:100%;margin-bottom:15px;">
        <thead>
          <tr>
            <th>Code</th>
            <th>Stake</th>
            <th>Payout</th>
            <th>Status</th>
          </tr>
        </thead>
        <tbody>
          ${betDetails.map(b => `<tr>
            <td>${b.code}</td>
            <td>${b.stake}</td>
            <td>${b.payout}</td>
            <td style="color:${b.status==="WIN"?"green":"red"};font-weight:bold;">${b.status}</td>
          </tr>`).join("")}
          <tr>
            <th>Total</th>
            <th>${totalStake}</th>
            <th>${totalPayout}</th>
            <th>Net: ${net}</th>
          </tr>
        </tbody>
      </table>`;

    // ---------- Covered Bets Table ----------
    html += `<table class="table" border="1" cellpadding="5" cellspacing="0" style="width:100%;margin-bottom:15px;">
      <thead>
        <tr><th colspan="4">üü¢ Covered Bets (${coveredList.length})</th></tr>
        <tr><th>Code</th><th>Stake</th><th>Payout</th><th>Status</th></tr>
      </thead>
      <tbody>
      ${coveredList.map(code => {
        const status = payouts[code] > 0 ? '<span style="color:green;font-weight:bold;">WIN</span>' : 'LOSE';
        return `<tr>
          <td>${code}</td>
          <td>${stakes[code]}</td>
          <td>${payouts[code]}</td>
          <td>${status}</td>
        </tr>`;
      }).join("")}
      </tbody>
    </table>`;

    // ---------- Uncovered Bets Table ----------
    html += `<table class="table" border="1" cellpadding="5" cellspacing="0" style="width:100%;margin-bottom:15px;">
      <thead>
        <tr><th colspan="3">üö´ Uncovered Bets (${uncoveredList.length})</th></tr>
        <tr><th>Code</th><th>Stake</th><th>Payout</th></tr>
      </thead>
      <tbody>
        ${uncoveredList.map(code => `<tr>
          <td>${code}</td>
          <td>0</td>
          <td>0</td>
        </tr>`).join("")}
      </tbody>
    </table>`;

    // ---------- Update DOM ----------
    result.innerHTML = html;

  } catch (e) {
    result.innerHTML = `<p style="color:red;">‚ùå Invalid JSON: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- Call FUNKY TIME ----------
if (game === "funkytime") {
  EVOFunkyTimeCoverage(jsonText, result, badge);
}








// ---------- Crazy Time ----------
function CrazyTimeCoverage(jsonText, result, badge) {
  try {
    if (typeof jsonText !== 'string') jsonText = JSON.stringify(jsonText);
    const data = JSON.parse(jsonText);

    const validBets = [
      "CT_1","CT_2","CT_5","CT_10",
      "CT_CashHunt","CT_Pachinko","CT_CoinFlip","CT_CrazyTime"
    ];
    const normalizationMap = {
      "CT_CASHHUNT": "CT_CashHunt",
      "CT_PACHINKO": "CT_Pachinko",
      "CT_COINFLIP": "CT_CoinFlip",
      "CT_CRAZYTIME": "CT_CrazyTime"
    };

    let betDetails = [];
    let uniqueBets = new Set();
    let stakes = {};
    let payouts = {};
    let totalStake = 0;
    let totalPayout = 0;

    data.forEach(entry => {
      if (!entry.code) return;
      const code = normalizationMap[entry.code.toUpperCase()] || entry.code.trim();
      if (!validBets.includes(code)) return;

      uniqueBets.add(code);
      const stake = entry.stake || 0;
      const payout = entry.payout || 0;
      totalStake += stake;
      totalPayout += payout;

      stakes[code] = (stakes[code] || 0) + stake;
      payouts[code] = (payouts[code] || 0) + payout;

      betDetails.push({ code, stake, payout, status: payout > 0 ? "WIN" : "LOSE" });
    });

    const coveredList = Array.from(uniqueBets).sort();
    const uncoveredList = validBets.filter(code => !uniqueBets.has(code)).sort();
    const coveragePercent = (coveredList.length / validBets.length) * 100;
    
    // ‚úÖ ARB only if ALL bets are covered
    const isArb = coveredList.length === validBets.length;

    const net = (totalPayout - totalStake).toFixed(2);

    // ---------- Crazy Time Bets Table ----------
    const betsTable = `
      <div class="section">
        <h3>üåÄ Crazy Time Bets Table</h3>
        <table class="table">
          <thead>
            <tr><th>Code</th><th>Stake</th><th>Payout</th><th>Status</th></tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.code}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td style="color:${b.status==="WIN"?"#0f0":"#f00"}; font-weight:bold;">${b.status}</td>
              </tr>
            `).join('')}
            <tr>
              <th>Total</th>
              <th>${totalStake}</th>
              <th>${totalPayout}</th>
              <th>Net: ${net}</th>
            </tr>
          </tbody>
        </table>
      </div>
    `;

    // ---------- Coverage sum.. ----------
    const coverageTable = `
      <div class="section">
        <h3>üìä Coverage Summary</h3>
        <table class="table">
          <tr><th>Covered Bets</th><td>${coveredList.length}/${validBets.length}</td></tr>
          <tr><th>Coverage %</th><td>${coveragePercent.toFixed(2)}%</td></tr>
          <tr><th>Uncovered Bets</th><td>${uncoveredList.join(', ') || 'None'}</td></tr>
        </table>
      </div>
    `;

    // ---------- Covered Bets Table ----------
    const coveredTable = `
      <div class="section">
        <h3>üü¢ Covered Bets (${coveredList.length})</h3>
        <table class="table">
          <thead>
            <tr><th>Code</th><th>Stake</th><th>Payout</th><th>Status</th></tr>
          </thead>
          <tbody>
            ${coveredList.map(code => {
              const status = payouts[code] > 0 ? "WIN" : "LOSE";
              return `
                <tr>
                  <td>${code}</td>
                  <td>${stakes[code] || 0}</td>
                  <td>${payouts[code] || 0}</td>
                  <td style="color:${status==="WIN"?"#0f0":"#f00"}; font-weight:bold;">${status}</td>
                </tr>
              `;
            }).join('')}
          </tbody>
        </table>
      </div>
    `;

    // ---------- Uncovered Bets Table ----------
    const uncoveredTable = `
      <div class="section">
        <h3>üö´ Uncovered Bets (${uncoveredList.length})</h3>
        <table class="table">
          <thead>
            <tr><th>Code</th><th>Status</th></tr>
          </thead>
          <tbody>
            ${uncoveredList.map(code => `
              <tr>
                <td>${code}</td>
                <td style="color:#f00; font-weight:bold;">Uncovered</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>
    `;

    // ---------- Render All ----------
    result.innerHTML = betsTable + coverageTable + coveredTable + uncoveredTable;

    // ---------- Badge ----------
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveredList.length}/${validBets.length})`;

  } catch(e) {
    result.innerHTML = `<p>‚ö†Ô∏è Invalid JSON or format: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- call CrazyTimeCoverage ----------
if (game === "crazytime") {
  CrazyTimeCoverage(jsonText, result, badge);
}





// ---------- Kingmaker 32 Cards ----------
function Kingmaker32Cards(jsonInput, result, badge) {
  try {
    // Ensure input is JSON string
    if (typeof jsonInput !== 'string') jsonInput = JSON.stringify(jsonInput);
    const data = JSON.parse(jsonInput);

    const betString = data.betType || '';
    const validOptions = ['ttc-8', 'ttc-9', 'ttc-10', 'ttc-11'];
    const betEntries = betString.split(',').map(e => e.trim());

    let totalStake = 0;
    const betSummary = {};

    // Parse bets and calculate stake
    betEntries.forEach(entry => {
      const [code, stakeStr] = entry.split(':').map(s => s.trim());
      if (!validOptions.includes(code)) return;

      const stake = parseFloat(stakeStr) || 0;
      if (!betSummary[code]) betSummary[code] = { stake: 0, payout: 0 };
      betSummary[code].stake += stake;
      totalStake += stake;
    });

    // Apply payout proportional to stake
    const totalPayout = parseFloat(data.profit) || 0;
    const covered = Object.keys(betSummary);
    covered.forEach(o => {
      betSummary[o].payout = (betSummary[o].stake / totalStake) * totalPayout;
    });

    // Determine coverage and arb status
    const uncovered = validOptions.filter(o => !covered.includes(o));
    const coveragePercent = (covered.length / validOptions.length) * 100;
    const isArb = coveragePercent >= 75;

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üÉè Kingmaker 32 Cards Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Option</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${covered.map(o => `
              <tr>
                <td>${o.toUpperCase()}</td>
                <td>${betSummary[o].stake}</td>
                <td>${betSummary[o].payout.toFixed(2)}</td>
                <td>${betSummary[o].payout > 0 
                  ? '<span class="badge badge-win">WIN</span>' 
                  : '<span class="badge badge-lose">LOSE</span>'}</td>
              </tr>
            `).join('')}
            <tr>
              <th>Total</th>
              <td>${totalStake}</td>
              <td>${totalPayout.toFixed(2)}</td>
              <td>Net: ${(totalPayout - totalStake).toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Options (${covered.length}/${validOptions.length})</h3>
        <table class="table">
          <thead><tr><th>Option</th><th>Stake</th><th>Payout</th></tr></thead>
          <tbody>
            ${covered.map(o => `
              <tr>
                <td>${o.toUpperCase()}</td>
                <td>${betSummary[o].stake}</td>
                <td>${betSummary[o].payout.toFixed(2)}</td>
              </tr>
            `).join('')}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üö´ Not Covered Options (${uncovered.length}/${validOptions.length})</h3>
        <table class="table">
          <thead><tr><th>Option</th></tr></thead>
          <tbody>
            ${uncovered.map(o => `<tr><td>${o.toUpperCase()}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;

    // ---------- Badge ----------
    badge.className = `status-badge ${isArb ? 'status-arb' : 'status-notarb'}`;
    badge.textContent = `${isArb ? 'ARB ‚úÖ' : 'NOT ARB ‚ùå'} | ${coveragePercent.toFixed(2)}%`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Kingmaker 32 Cards JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- uwu King Maker 32 Cards caller uwu ----------
if (game === "kingmaker32") {
  Kingmaker32Cards(jsonText, result, badge);
}





// ----------Lightning Storm EVO----------
function LightningStormBets(jsonText, result, badge) {
  try {
    const MAX_POSITIONS = 20;
    const TOTAL_CODES = Array.from({ length: MAX_POSITIONS }, (_, i) => `LSt_${i + 1}`);

    const data = JSON.parse(jsonText);
    const betSummary = {};
    let totalStake = 0;
    let totalPayout = 0;

    data.forEach(bet => {
      const { code, stake, payout } = bet;
      if (!betSummary[code]) betSummary[code] = { stake: 0, payout: 0 };
      betSummary[code].stake += Number(stake || 0);
      betSummary[code].payout += Number(payout || 0);
      totalStake += Number(stake || 0);
      totalPayout += Number(payout || 0);
    });

    const covered = Object.keys(betSummary);
    const uncovered = TOTAL_CODES.filter(c => !covered.includes(c));
    const coveragePercent = (covered.length / TOTAL_CODES.length) * 100;
    const isArb = coveragePercent >= 85;

    // ---------- CSS Styles ----------
    const styles = `
      <style>
        .ls-section { margin-bottom: 20px; font-family: 'Segoe UI', Tahoma, sans-serif; }
        .ls-section h3 { color: #0ff; margin-bottom: 8px; }
        .ls-table { width: 100%; border-collapse: collapse; background: #111; color: #fff; border-radius: 8px; overflow: hidden; }
        .ls-table th, .ls-table td { padding: 8px 12px; text-align: center; }
        .ls-table th { background: #0a1f26; }
        .ls-table tr:nth-child(even) { background: #1a1a1a; }
        .ls-table tr:hover { background: #0f2c35; }
        .badge-win { color: #0f0; font-weight: bold; }
        .badge-lose { color: #f00; font-weight: bold; }
        .status-badge { display: inline-block; padding: 4px 10px; font-weight: bold; border-radius: 5px; margin-bottom: 10px; color: #fff; }
        .status-arb { background-color: #0f0; border: 2px solid #0f0; color: #000; }
        .status-notarb { background-color: #f00; border: 2px solid #f00; color: #000; }
        .status-warning { background-color: #ffa500; border: 2px solid #ffa500; color: #000; }
      </style>
    `;

    // ---------- Covered Table ----------
    const coveredTable = `
      <div class="ls-section">
        <h3>‚ö° Covered Positions (${covered.length}/${TOTAL_CODES.length})</h3>
        <table class="ls-table">
          <thead><tr><th>Code</th><th>Stake</th><th>Payout</th><th>Net</th><th>Status</th></tr></thead>
          <tbody>
            ${covered.map(c => {
              const b = betSummary[c];
              const net = b.payout - b.stake;
              const status = b.payout > 0 ? 'WIN' : 'LOSE';
              const color = b.payout > 0 ? '#0f0' : '#f00';
              return `<tr>
                <td>${c}</td>
                <td>${b.stake}</td>
                <td>${b.payout.toFixed(2)}</td>
                <td>${net.toFixed(2)}</td>
                <td style="color:${color}; font-weight:bold;">${status}</td>
              </tr>`;
            }).join('')}
            <tr>
              <th>Total</th>
              <th>${totalStake}</th>
              <th>${totalPayout.toFixed(2)}</th>
              <th>${(totalPayout-totalStake).toFixed(2)}</th>
              <th>Coverage: ${coveragePercent.toFixed(2)}%</th>
            </tr>
          </tbody>
        </table>
      </div>
    `;

    // ---------- Uncovered Table ----------
    const uncoveredTable = `
      <div class="ls-section">
        <h3>üö´ Not Covered Codes (${uncovered.length}/${TOTAL_CODES.length})</h3>
        <table class="ls-table">
          <thead><tr><th>Position</th></tr></thead>
          <tbody>
            ${uncovered.map(c => `<tr><td>${c}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;

    // ---------- Update DOM ----------
    result.innerHTML = styles + coveredTable + uncoveredTable;

    // ---------- Badge ----------
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} | ${coveragePercent.toFixed(2)}%`;

  } catch(e) {
    result.innerHTML = `<p>‚ö†Ô∏è Invalid JSON or format: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- calling LightningStormBets ----------
if (game === "lightningstorm") {
  LightningStormBets(jsonText, result, badge);
}






// ---------- Mega Wheel Arb Analyzer ----------
function checkMegaWheelArb(jsonText, result, badge) {
  const MEGA_WHEEL_NUMBERS = [1, 2, 5, 8, 10, 15, 20, 30, 40];
  const TOTAL = MEGA_WHEEL_NUMBERS.length;

  try {
    const data = JSON.parse(jsonText);
    const betString = data.betInfos[0]["roundDetails-bet"];
    const settleString = data["roundDetails-settle"];

    // Extract bets
    const betMatch = betString.match(/desc:(\[[^\]]+\])/);
    const settleMatch = settleString.match(/desc:(\[[^\]]+\])/);
    if (!betMatch || !settleMatch) {
      result.innerHTML = `<p>‚ö†Ô∏è Invalid Mega Wheel JSON structure.</p>`;
      return;
    }

    const betArray = JSON.parse(betMatch[1]);
    const settleArray = JSON.parse(settleMatch[1]);

    // Map results
    const betMap = {};
    let totalStake = 0, totalPayout = 0;

    betArray.forEach(b => {
      betMap[b.c] = { stake: Number(b.a), payout: 0 };
      totalStake += Number(b.a);
    });

    settleArray.forEach(s => {
      if (betMap[s.c]) {
        betMap[s.c].payout = Number(s.a);
        totalPayout += Number(s.a);
      }
    });

    // Coverage
    const covered = MEGA_WHEEL_NUMBERS.filter(n => betMap[n]);
    const uncovered = MEGA_WHEEL_NUMBERS.filter(n => !betMap[n]);
    const coveragePercent = (covered.length / TOTAL) * 100;
    const isArb = coveragePercent >= 85;

    // ---------- Render Tables ----------
    result.innerHTML = `
      <div class="section"><h3>üé° Mega Wheel Bets Table</h3>
        <table class="table">
          <thead>
            <tr><th>Number</th><th>Stake</th><th>Payout</th><th>Win?</th></tr>
          </thead>
          <tbody>
            ${covered.map(n => `
              <tr>
                <td>${n}</td>
                <td>${betMap[n].stake}</td>
                <td>${betMap[n].payout}</td>
                <td>${betMap[n].payout > 0 ? '<span class="badge badge-win">Win</span>' : ''}</td>
              </tr>`).join("")}
            <tr>
              <th>Total</th>
              <td>${totalStake}</td>
              <td>${totalPayout}</td>
              <td>Net: ${(totalPayout - totalStake).toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Numbers (${covered.length}/${TOTAL})</h3>
        <table class="table">
          <thead><tr><th>Number</th><th>Stake</th><th>Payout</th></tr></thead>
          <tbody>
            ${covered.map(n => `
              <tr>
                <td>${n}</td>
                <td>${betMap[n].stake}</td>
                <td>${betMap[n].payout}</td>
              </tr>`).join("")}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üö´ Uncovered Numbers (${uncovered.length}/${TOTAL})</h3>
        <table class="table">
          <thead><tr><th>Number</th></tr></thead>
          <tbody>
            ${uncovered.map(n => `<tr><td>${n}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    // Status Badge
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} | ${coveragePercent.toFixed(2)}%`;

  } catch (e) {
    result.innerHTML = `<p>‚ùå Error parsing Mega Wheel JSON: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- callzzzzz megawheel ----------
if (game === "megawheel") {
  checkMegaWheelArb(jsonText, result, badge);
}







// ---------- RACE TRACK BETS the horses na cnasabi ni sir noon----------
// all 6 possible outcome are wagered its arb daw
function RaceTrackBets(jsonString, result, badge) {
  try {
    const data = JSON.parse(jsonString);

    const racerPattern = /^RT_Racer(\d{1,2})$/;
    const uniqueRacers = new Set();

    // Collect racers bet on
    data.forEach(entry => {
      if (entry.code && entry.code.match(racerPattern)) {
        uniqueRacers.add(entry.code);
      }
    });

    const totalPossibleRacers = 6; // always 6 horses
    const totalBetRacers = uniqueRacers.size;
    const coveragePercent = (totalBetRacers / totalPossibleRacers) * 100;
    const isArb = totalBetRacers === totalPossibleRacers;

    // Bet details
    const betDetails = data.map(b => ({
      code: b.code,
      stake: b.stake || 0,
      payout: b.payout || 0,
      net: ((b.payout || 0) - (b.stake || 0)).toFixed(2),
      winBadge: (b.payout || 0) > 0 ? '<span class="badge badge-win">Win</span>' : ''
    }));

    // Totals
    const totalStake = betDetails.reduce((sum, b) => sum + b.stake, 0);
    const totalPayout = betDetails.reduce((sum, b) => sum + b.payout, 0);
    const totalNet = (totalPayout - totalStake).toFixed(2);

    // ---------- Render ----------
    result.innerHTML = `
      <div class="section"><h3>üèá Race Track Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Bet Code</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Net</th>
              <th>Winning?</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.code}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td>${b.net}</td>
                <td>${b.winBadge}</td>
              </tr>
            `).join("")}
            <tr>
              <th>Total</th>
              <th>${totalStake}</th>
              <th>${totalPayout}</th>
              <th>${totalNet}</th>
              <th></th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Racers Covered (${totalBetRacers}/${totalPossibleRacers})</h3>
        <table class="table">
          <thead><tr><th>Racer</th></tr></thead>
          <tbody>
            ${[...uniqueRacers].map(r => `<tr><td>${r}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (e) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Race Track JSON: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- calling racetrack ----------
if (game === "racetrack") {
  RaceTrackBets(jsonText, result, badge);
}








// ---------- ICE FISHING BETS evo----------
// same logic as horse track
// all 6 possible outcomes wagered == ARB
function IceFishingBetsEVO(jsonString, result, badge) {
  try {
    const data = JSON.parse(jsonString);

    // All possible bets
    const allBets = [
      "IF_BigOranges",
      "IF_HugeReds",
      "IF_Leaf1",
      "IF_Leaf2",
      "IF_AllBonuses",
      "IF_LilBlues"
    ];

    // Collect unique bets placed
    const uniqueBets = new Set();
    data.forEach(entry => {
      if (entry.code && allBets.includes(entry.code)) {
        uniqueBets.add(entry.code);
      }
    });

    // Arb logic== all 6 bets must be covered
    const totalBets = allBets.length;
    const totalCovered = uniqueBets.size;
    const coveragePercent = (totalCovered / totalBets) * 100;
    const isArb = totalCovered === totalBets;

    // Bet details
    const betDetails = data.map(b => ({
      code: b.code,
      stake: b.stake || 0,
      payout: b.payout || 0,
      net: ((b.payout || 0) - (b.stake || 0)).toFixed(2),
      winBadge: (b.payout || 0) > 0 ? '<span class="badge badge-win">Win</span>' : '<span class="badge badge-loss">Lost</span>'
    }));

    // Totals
    const totalStake = betDetails.reduce((sum, b) => sum + b.stake, 0);
    const totalPayout = betDetails.reduce((sum, b) => sum + b.payout, 0);
    const totalNet = (totalPayout - totalStake).toFixed(2);

    // Covered / Uncovered lists
    const coveredBets = [...uniqueBets];
    const uncoveredBets = allBets.filter(b => !uniqueBets.has(b));

    // ---------- Render ----------
    result.innerHTML = `
      <div class="section"><h3>üé£ Ice Fishing Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Bet Code</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Net</th>
              <th>Winning?</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.code}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td>${b.net}</td>
                <td>${b.winBadge}</td>
              </tr>
            `).join("")}
            <tr>
              <th>Total</th>
              <th>${totalStake}</th>
              <th>${totalPayout}</th>
              <th>${totalNet}</th>
              <th></th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Bets (${coveredBets.length}/${totalBets})</h3>
        <table class="table">
          <thead><tr><th>Bet</th></tr></thead>
          <tbody>
            ${coveredBets.map(b => `<tr><td>${b}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>‚ö†Ô∏è Uncovered Bets (${uncoveredBets.length}/${totalBets})</h3>
        <table class="table">
          <thead><tr><th>Bet</th></tr></thead>
          <tbody>
            ${uncoveredBets.map(b => `<tr><td>${b}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    // Badge status
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (e) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Ice Fishing JSON: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- Call icefishing ----------
if (game === "icefishing") {
  IceFishingBetsEVO(jsonText, result, badge);
}










// ---------- MEGA BALL Coverage THATS WHAT SHE SAID LOL ----------
function MegaBallBets(jsonString, result, badge) {
  try {
    const data = JSON.parse(jsonString);
    if (!Array.isArray(data)) throw new Error("Expected an array of bets");

    let totalCards = 0;
    let totalStake = 0;
    let totalPayout = 0;
    const coveredCards = new Set();

    const betDetails = data.map(b => {
      let cards = 0;
      if (b.code) {
        let match = b.code.match(/^MB_(\d+)Cards$/);
        if (match) {
          cards = parseInt(match[1], 10);
          totalCards += cards;
          for (let i = 1; i <= cards; i++) {
            coveredCards.add(i);
          }
        }
      }
      totalStake += b.stake || 0;
      totalPayout += b.payout || 0;

      return {
        code: b.code,
        cards: cards,
        stake: b.stake || 0,
        payout: b.payout || 0,
        net: ((b.payout || 0) - (b.stake || 0)).toFixed(2),
        winBadge: (b.payout || 0) > 0 ? '<span class="badge badge-win">Win</span>' : '<span class="badge badge-loss">Lost</span>'
      };
    });

    const totalNet = (totalPayout - totalStake).toFixed(2);

    // Coverage logic (400 max cards)
    const coveragePercent = (totalCards / 400) * 100;
    const isArb = coveragePercent >= 85;

    // Build covered/uncovered lists
    const allCards = Array.from({ length: 400 }, (_, i) => i + 1);
    const coveredList = allCards.filter(c => coveredCards.has(c));
    const uncoveredList = allCards.filter(c => !coveredCards.has(c));

    // Convert list ‚Üí ranges
    function compressRanges(arr) {
      if (arr.length === 0) return [];
      const ranges = [];
      let start = arr[0], prev = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] === prev + 1) {
          prev = arr[i];
        } else {
          ranges.push(start === prev ? `${start}` : `${start}-${prev}`);
          start = arr[i];
          prev = arr[i];
        }
      }
      ranges.push(start === prev ? `${start}` : `${start}-${prev}`);
      return ranges;
    }

    const coveredRanges = compressRanges(coveredList);
    const uncoveredRanges = compressRanges(uncoveredList);

    // ---------- Render ----------
    result.innerHTML = `
      <div class="section"><h3>üé± Mega Ball Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Bet Code</th>
              <th>Cards</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Net</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${betDetails.map(b => `
              <tr>
                <td>${b.code}</td>
                <td>${b.cards}</td>
                <td>${b.stake}</td>
                <td>${b.payout}</td>
                <td>${b.net}</td>
                <td>${b.winBadge}</td>
              </tr>
            `).join("")}
            <tr>
              <th>Total</th>
              <th>${totalCards}</th>
              <th>${totalStake}</th>
              <th>${totalPayout}</th>
              <th>${totalNet}</th>
              <th></th>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üìä Coverage Summary</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Total Cards Covered</th>
              <th>Total Cards Not Covered</th>
              <th>Coverage %</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>${coveredList.length}</td>
              <td>${uncoveredList.length}</td>
              <td>${coveragePercent.toFixed(2)}%</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>‚úÖ Covered Cards</h3>
        <div style="max-height:150px; overflow-y:auto; border:1px solid #333; padding:8px;">
          ${coveredRanges.length > 0 ? coveredRanges.join(", ") : "‚ùå No cards covered"}
        </div>
      </div>

      <div class="section"><h3>üö´ Uncovered Cards</h3>
        <div style="max-height:150px; overflow-y:auto; border:1px solid #333; padding:8px;">
          ${uncoveredRanges.length > 0 ? uncoveredRanges.join(", ") : "‚úÖ All 400 cards covered"}
        </div>
      </div>
    `;

    // Badge
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (e) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Mega Ball JSON: ${e.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}



// ---------- iwill call Megaball ----------
if (game === "megaball") {
  MegaBallBets(jsonText, result, badge);
}





// ---------- Kingmaker Color Game checker ----------
function KingmakerColorGame(jsonInput, result, badge) {
  try {
    if (typeof jsonInput !== 'string') jsonInput = JSON.stringify(jsonInput);
    const data = JSON.parse(jsonInput);

    const betString = data.betType || '';
    const betEntries = betString.split(',').map(e => e.trim()).filter(e => e);

    // ----- Valid betting options -----
    const singleColors = ['cg-yellow','cg-pink','cg-blue','cg-red','cg-white','cg-green'];
    const colorPairs = [
      'cg-yellow-pink','cg-yellow-blue','cg-yellow-red','cg-yellow-white','cg-yellow-green',
      'cg-pink-blue','cg-pink-red','cg-pink-white','cg-pink-green',
      'cg-blue-red','cg-blue-white','cg-blue-green',
      'cg-red-white','cg-red-green',
      'cg-white-green'
    ];
    const validOptions = [...singleColors, ...colorPairs];

    const betSummary = {};
    let totalStake = 0;
    let totalPayout = parseFloat(data.profit) || 0;
    const gameResult = (data.gameResult || "").toLowerCase();

    // ----- Parse bets -----
    betEntries.forEach(entry => {
      const [code, stakeStr] = entry.split(':').map(s => s.trim());
      if (validOptions.includes(code)) {
        const stake = parseFloat(stakeStr) || 0;
        if (!betSummary[code]) betSummary[code] = { stake: 0, payout: 0, win: false };
        betSummary[code].stake += stake;

        // Check win condition
        if (singleColors.includes(code) && gameResult.includes(code.replace('cg-',''))) {
          betSummary[code].win = true;
          betSummary[code].payout = stake * 2; // 1:1 payout
        }
        if (colorPairs.includes(code)) {
          const parts = code.replace('cg-','').split('-');
          if (parts.every(c => gameResult.includes(c))) {
            betSummary[code].win = true;
            betSummary[code].payout = stake * 6; // 1:5 payout (stake+5√óstake)
          }
        }

        totalStake += stake;
      }
    });

    // ----- Calculate covered/uncovered -----
    const covered = Object.keys(betSummary);
    const uncovered = validOptions.filter(o => !covered.includes(o));
    const coveragePercent = (covered.length / validOptions.length) * 100;
    const isArb = coveragePercent >= 85;

    // ----- Render output -----
    result.innerHTML = `
      <div class="section"><h3>üé® Kingmaker Color Game Bets</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Option</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Status</th>
            </tr>
          </thead>
          <tbody>
            ${covered.map(o => `<tr>
              <td>${o.replace('cg-','').toUpperCase()}</td>
              <td>${betSummary[o].stake}</td>
              <td>${betSummary[o].payout.toFixed(2)}</td>
              <td>${betSummary[o].win ? '<span class="badge badge-win">WIN</span>' : '<span class="badge badge-lose">LOSE</span>'}</td>
            </tr>`).join('')}
            <tr>
              <th>Total</th>
              <td>${totalStake}</td>
              <td>${totalPayout.toFixed(2)}</td>
              <td>Net: ${(totalPayout-totalStake).toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Options (${covered.length}/${validOptions.length})</h3>
        <table class="table">
          <thead><tr><th>Option</th><th>Stake</th><th>Payout</th></tr></thead>
          <tbody>
            ${covered.map(o => `<tr>
              <td>${o.replace('cg-','').toUpperCase()}</td>
              <td>${betSummary[o].stake}</td>
              <td>${betSummary[o].payout.toFixed(2)}</td>
            </tr>`).join('')}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üö´ Not Covered Options (${uncovered.length}/${validOptions.length})</h3>
        <table class="table">
          <thead><tr><th>Option</th></tr></thead>
          <tbody>
            ${uncovered.map(o => `<tr><td>${o.replace('cg-','').toUpperCase()}</td></tr>`).join('')}
          </tbody>
        </table>
      </div>
    `;

    // ----- Badge -----
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} | ${coveragePercent.toFixed(2)}%`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Kingmaker Color Game JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

if (game === "colorgame") {
  KingmakerColorGame(jsonText, result, badge);
}






// ---------- Andar Bahar coverage ----------
function andarBaharRanges(jsonText, result, badge) {
  try {
    const BASE_RANGES = [
      "andar", "bahar",
      "1-5","6-10","11-15","16-20","21-25","26-30","31-35","36-40","41"
    ];
    const betSummary = {};
    let totalStake = 0, totalPayout = 0;
    let totalProfit = 0;

    const data = JSON.parse(jsonText);
    const bets = Array.isArray(data) ? data : [data];

    let betOnAndar = false;
    let betOnBahar = false;

    for (const item of bets) {
      if (!item.betType) continue;
      const parts = item.betType.split(",").map(s => s.trim());

      totalProfit += parseFloat(item.profit || 0);

      for (const part of parts) {
        // Match format: ab-Andar:50|payout=200 or ab-16-20:50|payout=200
        const match = part.match(/^ab-(\w+(?:-\d+)?(?:-\d+)?)\s*:\s*(\d+(\.\d+)?)(?:\|payout=(\d+(\.\d+)?))?$/i);
        if (match) {
          const range = match[1];
          const stake = parseFloat(match[2]) || 0;
          const payout = parseFloat(match[4]) || (parseFloat(item.profit || 0) + stake);

          if (!betSummary[range]) betSummary[range] = { stake: 0, payout: 0 };
          betSummary[range].stake += stake;
          betSummary[range].payout += payout;

          totalStake += stake;
          totalPayout += payout;

          if (range.toLowerCase() === "andar") betOnAndar = true;
          if (range.toLowerCase() === "bahar") betOnBahar = true;
        }
      }
    }

    const covered = BASE_RANGES.filter(r => betSummary[r]);
    const uncovered = BASE_RANGES.filter(r => !betSummary[r]);
    let coveragePercent = (covered.length / BASE_RANGES.length) * 100;

    // ---------- player betted on both andar and bahar = automatic arb ----------
    let isArb = coveragePercent >= 85;
    if (betOnAndar && betOnBahar) {
      isArb = true;
      coveragePercent = 100;
    }

    // ---------- Render Table ----------
    result.innerHTML = `
      <div class="section"><h3>üé≤ Andar Bahar Bets Table</h3>
        <table class="table">
          <thead>
            <tr>
              <th>Range / Side</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Winning?</th>
            </tr>
          </thead>
          <tbody>
            ${BASE_RANGES.map(r => {
              let status = "";
              if (!betSummary[r]) status = '<span class="badge badge-notbet">No Wager</span>';
              else if (betSummary[r].payout > 0) status = '<span class="badge badge-win">Win</span>';
              else status = '<span class="badge badge-lost">Lost</span>';
              return `<tr>
                <td>${r}</td>
                <td>${betSummary[r] ? betSummary[r].stake : 0}</td>
                <td>${betSummary[r] ? betSummary[r].payout : 0}</td>
                <td>${status}</td>
              </tr>`;
            }).join("")}
            <tr>
              <th>Total</th>
              <td>${totalStake}</td>
              <td>${totalPayout}</td>
              <td>Profit: ${totalProfit.toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üü¢ Covered Bets (${covered.length}/${BASE_RANGES.length})</h3>
        <table class="table">
          <thead><tr><th>Range / Side</th><th>Stake</th><th>Payout</th></tr></thead>
          <tbody>
            ${covered.map(r => `<tr>
              <td>${r}</td>
              <td>${betSummary[r].stake}</td>
              <td>${betSummary[r].payout}</td>
            </tr>`).join("")}
          </tbody>
        </table>
      </div>

      <div class="section"><h3>üö´ Not Covered Bets (${uncovered.length}/${BASE_RANGES.length})</h3>
        <table class="table">
          <thead><tr><th>Range / Side</th></tr></thead>
          <tbody>
            ${uncovered.map(r => `<tr><td>${r}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Andar Bahar JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- Call when selected ----------
if (game === "andarbahar") {
  andarBaharRanges(jsonText, result, badge);
}




// ---------- Crazy Balls EVO ----------
if (game === "crazyballs") {
  let bets;
  try { 
    bets = JSON.parse(jsonText); 
  } catch { 
    result.innerHTML = "<p>‚ö†Ô∏è Invalid JSON or empty input</p>"; 
    badge.className = "status-badge status-warning"; 
    badge.textContent = "Error"; 
    return; 
  }

  if (!bets?.length) { 
    result.innerHTML = "<p>‚ö†Ô∏è No bets placed</p>"; 
    badge.className = "status-badge status-warning"; 
    badge.textContent = "Error"; 
    return; 
  }

  // --- Define all possible game cards ---
  const BASE_CARDS = ["SB_FreeSpaceCard1","SB_FreeSpaceCard2","SB_MultiCard3","SB_MultiCard4"];
  const BONUS_CARDS = ["SB_CCFBonus","SB_HuntBonus","SB_PachinkoBonus","SB_CrazyTimeBonus"];
  const ALL_CARDS = [...BASE_CARDS, ...BONUS_CARDS];

  const CARD_COVERAGE = 20, BONUS_COVERAGE = 10; // fixed units for calculation

  let totalStake = 0, totalPayout = 0;
  const coveredBets = [];
  const placedCodes = new Set();

  // --- Analyze placed bets ---
  bets.forEach(b => {
    totalStake += Number(b.stake) || 0;
    totalPayout += Number(b.payout) || 0;
    placedCodes.add(b.code);

    if (BASE_CARDS.includes(b.code)) {
      coveredBets.push({...b, group:"Main Card", covered:CARD_COVERAGE});
    } else if (BONUS_CARDS.includes(b.code)) {
      coveredBets.push({...b, group:"Bonus", covered:BONUS_COVERAGE});
    } else {
      // Other unrecognized bets (optional)
      coveredBets.push({...b, group:"Other", covered:0});
    }
  });

  // --- Determine uncovered bets (cards not wagered on) ---
  const uncoveredBets = ALL_CARDS
    .filter(code => !placedCodes.has(code))
    .map(code => ({code, stake:0, payout:0, group:"Uncovered", covered:0}));

  // --- Calculate actual coverage % ---
  const totalPossibleCoverage = BASE_CARDS.length * CARD_COVERAGE + BONUS_CARDS.length * BONUS_COVERAGE;
  const actualCoveredUnits = coveredBets.reduce((sum,b)=>sum+b.covered,0);
  const coveredPercent = (actualCoveredUnits / totalPossibleCoverage) * 100;
  const status = coveredPercent >= 85 ? "ARB" : "Not ARB";
  const net = (totalPayout - totalStake).toFixed(2);

  // --- Badge ---
  badge.className = "status-badge " + (status==="ARB"?"status-arb":"status-notarb");
  badge.textContent = `${status} (${coveredPercent.toFixed(2)}%)`;

  // --- Covered bets table ---
  const coveredRows = coveredBets.map(b => `
    <tr>
      <td>${b.code}</td>
      <td>${b.stake}</td>
      <td>${b.payout}</td>
      <td>${b.group}</td>
      <td>${b.covered}%</td>
      <td>${b.payout>0?'<span class="badge badge-win">Win</span>':''}</td>
    </tr>
  `).join("");

  // --- Uncovered bets table ---
  const uncoveredRows = uncoveredBets.map(b => `
    <tr>
      <td>${b.code}</td>
      <td>${b.stake}</td>
      <td>${b.payout}</td>
      <td>${b.group}</td>
      <td>${b.covered}%</td>
      <td>-</td>
    </tr>
  `).join("");

  // --- Output ---
  result.innerHTML = `
    <div class="section"><h3>üé± Covered Bets</h3>
      <table class="table">
        <tr><th>Bet Code</th><th>Stake</th><th>Payout</th><th>Category</th><th>Coverage</th><th>Result</th></tr>
        ${coveredRows || `<tr><td colspan="6">No covered bets</td></tr>`}
        <tr><th>Total</th><td>${totalStake}</td><td>${totalPayout}</td><td>-</td><td><strong>${coveredPercent.toFixed(2)}%</strong></td><td>Net: ${net}</td></tr>
      </table>
    </div>

    <div class="section"><h3>üö´ Uncovered Bets (Not Wagered)</h3>
      <table class="table">
        <tr><th>Bet Code</th><th>Stake</th><th>Payout</th><th>Category</th><th>Coverage</th><th>Result</th></tr>
        ${uncoveredRows.length ? uncoveredRows : `<tr><td colspan="6" style="text-align:center;">No uncovered bets</td></tr>`}
      </table>
    </div>

    <div class="section"><h3>üìä Coverage Summary</h3>
      <p>‚úÖ Total Coverage: <strong>${coveredPercent.toFixed(2)}%</strong> of 100%</p>
      <p>${status==="ARB"?"üü¢ Player covered ‚â•85% ‚Äî potential arbitrage detected!":"üî¥ Coverage below 85% ‚Äî not arbitrage."}</p>
    </div>
  `;
}






// COIN TOSS
function kingmakerCoinToss(jsonText, result, badge) {
  try {
    const POSSIBLE_BETS = [
      "ct-even", "ct-odd", "ct-3head-1tail", "ct-3tail-1head",
      "ct-2head-2tail", "ct-4head", "ct-4tail"
    ];
    const betSummary = {};
    let totalStake = 0;

    const data = JSON.parse(jsonText);
    const bets = Array.isArray(data) ? data : [data];

    // Parse bets
    for (const item of bets) {
      if (!item.betType) continue;
      const parts = item.betType.split(",").map(s => s.trim());

      for (const part of parts) {
        const match = part.match(/^(ct-\w+(?:-\w+)*)\s*:\s*(\d+(\.\d+)?)/i);
        if (!match) continue;

        const betName = match[1].toLowerCase();
        const stake = parseFloat(match[2]) || 0;

        if (!betSummary[betName]) betSummary[betName] = { stake: 0, payout: 0, outcomes: [] };
        betSummary[betName].stake += stake;
        totalStake += stake;
      }
    }

    const totalProfit = parseFloat(bets[0].profit || 0);
    const totalPayout = totalStake + totalProfit;

    // Assign proportional payouts
    const gameResult = (bets[0].gameResult || "").toLowerCase();
    if (gameResult === "win" && totalStake > 0) {
      for (const b in betSummary) {
        const bet = betSummary[b];
        if (bet && bet.stake > 0) {
          bet.payout = bet.stake + (totalProfit * (bet.stake / totalStake));
        }
      }
    }

    // 16 possible 4-coin outcomes
    const allOutcomes = [
      "HHHH","HHHT","HHTH","HHTT","HTHH","HTHT","HTTH","HTTT",
      "THHH","THHT","THTH","THTT","TTHH","TTHT","TTTH","TTTT"
    ];

    // Map each bet to the outcomes it covers
    for (const outcome of allOutcomes) {
      const heads = outcome.split("").filter(c => c==="H").length;
      const tails = 4 - heads;
      const evenOdd = (heads % 2 === 0) ? "ct-even" : "ct-odd"; // fixed

      POSSIBLE_BETS.forEach(b => {
        if (!betSummary[b]) return;
        if (
          (b === evenOdd) ||
          (b === "ct-4head" && heads === 4) ||
          (b === "ct-4tail" && tails === 4) ||
          (b === "ct-3head-1tail" && heads === 3 && tails === 1) ||
          (b === "ct-3tail-1head" && tails === 3 && heads === 1) ||
          (b === "ct-2head-2tail" && heads === 2 && tails === 2)
        ) {
          betSummary[b].outcomes.push(outcome);
        }
      });
    }

    // Collect covered outcomes
    const coveredOutcomes = new Set();
    POSSIBLE_BETS.forEach(b => {
      if (betSummary[b]) betSummary[b].outcomes.forEach(o => coveredOutcomes.add(o));
    });
    const coveragePercent = (coveredOutcomes.size / allOutcomes.length) * 100;

    // ---------- ARB Detection ----------
    let isArb = false;

    // Pattern 1: ct-even + ct-odd
    if ((betSummary["ct-even"]?.stake || 0) > 0 && (betSummary["ct-odd"]?.stake || 0) > 0) isArb = true;

    // Pattern 2: ct-2head-2tail + ct-even or ct-odd
    if ((betSummary["ct-2head-2tail"]?.stake || 0) > 0 &&
        ((betSummary["ct-even"]?.stake || 0) > 0 || (betSummary["ct-odd"]?.stake || 0) > 0)) isArb = true;

    // Pattern 3: ct-3head-1tail + ct-3tail-1head
    if ((betSummary["ct-3head-1tail"]?.stake || 0) > 0 && (betSummary["ct-3tail-1head"]?.stake || 0) > 0) isArb = true;

    // ---------- Render HTML ----------
    result.innerHTML = `
      <div class="section">
        <h3>üé≤ Kingmaker Coin Toss Bets Table</h3>
        <table class="table">
          <thead>
            <tr><th>Bet</th><th>Stake</th><th>Payout</th><th>Outcomes Covered</th><th>Coverage</th></tr>
          </thead>
          <tbody>
            ${POSSIBLE_BETS.map(b => {
              const bet = betSummary[b];
              if (!bet || bet.stake === 0) return `<tr>
                <td>${b}</td><td>0</td><td>0</td><td>-</td><td>0%</td>
              </tr>`;
              const coverage = (bet.outcomes.length / allOutcomes.length * 100).toFixed(2);
              return `<tr>
                <td>${b}</td>
                <td>${bet.stake.toFixed(2)}</td>
                <td>${bet.payout.toFixed(2)}</td>
                <td>${bet.outcomes.join(", ")}</td>
                <td>${bet.outcomes.length}/16 (${coverage}%)</td>
              </tr>`;
            }).join("")}
          </tbody>
        </table>
      </div>

      <div class="section">
        <h3>üí∞ Summary</h3>
        <table class="table">
          <tr><th>Total Stake</th><td>${totalStake.toFixed(2)}</td></tr>
          <tr><th>Total Payout</th><td>${totalPayout.toFixed(2)}</td></tr>
          <tr><th>Total Profit</th><td>${totalProfit.toFixed(2)}</td></tr>
          <tr><th>Total Outcome Coverage</th><td>${coveredOutcomes.size}/16 (${coveragePercent.toFixed(2)}%)</td></tr>
          <tr><th>ARB Status</th><td>${isArb ? "‚úÖ ARB" : "‚ùå Not ARB"}</td></tr>
        </table>
      </div>
    `;

    // Badge shows coverage % + ARB
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${coveragePercent.toFixed(2)}% Coverage ${isArb ? "‚úÖ ARB" : "‚ùå Not ARB"}`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Coin Toss JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}


// ---------- Call Kingmaker Coin Toss Function ----------
if (game === "cointoss") {
  kingmakerCoinToss(jsonText, result, badge);
}



// ---------- Dragon Tiger Phoenix Analyzer ----------
if (game === "dtp") {
  const boardOptions = new Set([
    "TRN_Q", // Dragon
    "TRN_Z", // Tiger
    "TRN_Y"  // Phoenix
  ]);

  const betDescriptions = {
    TRN_Q: "Dragon ‚Äî wins if Dragon card is higher",
    TRN_Z: "Tiger ‚Äî wins if Tiger card is higher",
    TRN_Y: "Phoenix ‚Äî special side bet (Evolution feature)"
  };

  try {
    const data = JSON.parse(jsonText);

    // Filter valid bets
    const betsUsed = data.filter(b => boardOptions.has(b.code));
    const uniqueBets = [...new Set(betsUsed.map(b => b.code))];

    // Board coverage % (1/3, 2/3, 3/3)
    const coveragePercent = (uniqueBets.length / boardOptions.size) * 100;

    // Unused bets
    const unusedBets = [...boardOptions].filter(b => !uniqueBets.includes(b));

    // Total stake & payout
    const totalStake = betsUsed.reduce((sum, b) => sum + Number(b.stake || 0), 0);
    const totalPayout = betsUsed.reduce((sum, b) => sum + Number(b.payout || 0), 0);
    const net = (totalPayout - totalStake).toFixed(2);

    // ---------- ARB Logic ----------
    // Strict: ARB only if all three sides are covered
    const isArb = uniqueBets.length > 2; // >2 = all 3 sides

    // Determine coverage pattern
    const coveragePattern = uniqueBets.join(" + ") || "No bets";

    // ---------- Render Table ----------
    result.innerHTML = `
      <div class="section"><h3>üêâ Dragon Tiger Phoenix Bets Table</h3>
        <table class="table">
          <tr><th>Bet Code</th><th>Description</th><th>Stake</th><th>Payout</th><th>Status</th></tr>
          ${betsUsed.map(b => `
            <tr>
              <td>${b.code}</td>
              <td>${betDescriptions[b.code] || "-"}</td>
              <td>${b.stake}</td>
              <td>${b.payout}</td>
              <td>${b.payout > 0
                ? '<span class="badge badge-win">Win</span>'
                : '<span class="badge badge-loss">Lost</span>'}</td>
            </tr>`).join("")}
          <tr>
            <th colspan="2">Total</th>
            <td>${totalStake}</td>
            <td>${totalPayout}</td>
            <td>Net: ${net}</td>
          </tr>
        </table>
      </div>

      <div class="section"><h3>üü¢ Coverage</h3>
        <table class="table">
          <tr><th>Metric</th><th>Value</th></tr>
          <tr><td>Active Bets</td><td>${uniqueBets.length} / ${boardOptions.size}</td></tr>
          <tr><td>Coverage Pattern</td><td>${coveragePattern}</td></tr>
          <tr><td>Board Coverage</td><td>${coveragePercent.toFixed(2)}%</td></tr>
          <tr><td>Unused Bets</td><td>${unusedBets.join(", ") || "-"}</td></tr>
        </table>
      </div>
    `;

    // ---------- Badge Status ----------
    if (isArb) {
      badge.className = "status-badge status-arb";
      badge.textContent = `ARB ‚úÖ (All 3 sides covered, ${coveragePercent.toFixed(2)}%)`;
    } else {
      badge.className = "status-badge status-notarb";
      badge.textContent = `NOT ARB ‚ùå (${coveragePattern}, ${coveragePercent.toFixed(2)}%)`;
    }

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing Dragon Tiger Phoenix JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}




// ---------- fantan kingmaker ----------
function ftBetAnalyzer(jsonText, result, badge) {
  try {
    // Total possible outcome numbers
    const POSSIBLE_NUMBERS = ["1", "2", "3", "4"];

    const betSummary = {};
    let totalStake = 0, totalPayout = 0;
    let totalProfit = 0; // Use profit from JSON

    // Parse JSON
    const data = JSON.parse(jsonText);
    const bets = Array.isArray(data) ? data : [data];

    const numbersCoveredSet = new Set();

    for (const item of bets) {
      if (!item.betType) continue;

      totalProfit += parseFloat(item.profit) || 0;

      const parts = item.betType.split(",").map(s => s.trim());

      for (const part of parts) {
        const match = part.match(/^([\w\-]+)\s*:\s*(\d+(\.\d+)?)/i);
        if (!match) continue;

        const betName = match[1].toLowerCase();
        const stake = parseFloat(match[2]) || 0;

        // ---------- FIXED PAYOUT LOGIC ----------
        let payout = stake;
        const profit = parseFloat(item.profit) || 0;
        const gameResult = (item.gameResult || "").toLowerCase();
        if (gameResult === "lose") payout = 0;
        else if (gameResult === "win") payout = stake + Math.max(profit, 0);

        if (!betSummary[betName]) betSummary[betName] = { stake: 0, payout: 0 };

        betSummary[betName].stake += stake;
        betSummary[betName].payout += payout;

        totalStake += stake;
        totalPayout += payout;

        // Extract numbers for coverage
        const nums = betName.match(/\d+/g) || [];
        nums.forEach(n => numbersCoveredSet.add(n));
      }
    }

    // Coverage
    const coveredNumbers = POSSIBLE_NUMBERS.filter(n => numbersCoveredSet.has(n));
    const uncoveredNumbers = POSSIBLE_NUMBERS.filter(n => !numbersCoveredSet.has(n));
    const coveragePercent = (coveredNumbers.length / POSSIBLE_NUMBERS.length) * 100;
    const isArb = coveragePercent >= 85;

    const betNumbersMap = {};
    Object.keys(betSummary).forEach(bet => {
      const nums = bet.match(/\d+/g);
      betNumbersMap[bet] = nums ? nums.join(",") : "";
    });

    // ---------- Render Result ----------
    result.innerHTML = `
      <div class="section">
        <h3>üé≤ FT Bets Table</h3>
        <table class="table" border="1" cellpadding="5">
          <thead>
            <tr>
              <th>Bet</th>
              <th>Stake</th>
              <th>Payout</th>
              <th>Status</th>
              <th>Outcome Numbers</th>
            </tr>
          </thead>
          <tbody>
            ${Object.keys(betSummary).map(bet => {
              const b = betSummary[bet];
              const status = b.payout > 0
                ? '<span class="badge badge-win" style="background-color:yellow;color:black;">Win</span>'
                : '<span class="badge badge-lost" style="color:red;">Lost</span>';
              return `<tr>
                        <td>${bet}</td>
                        <td>${b.stake.toFixed(2)}</td>
                        <td>${b.payout.toFixed(2)}</td>
                        <td>${status}</td>
                        <td>${betNumbersMap[bet]}</td>
                      </tr>`;
            }).join("")}
            <tr>
              <th>Total</th>
              <td>${totalStake.toFixed(2)}</td>
              <td>${totalPayout.toFixed(2)}</td>
              <td colspan="2">Net: ${totalProfit.toFixed(2)}</td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="section">
        <h3>üü¢ Covered Numbers (${coveredNumbers.length}/${POSSIBLE_NUMBERS.length})</h3>
        <table class="table" border="1" cellpadding="5">
          <thead><tr><th>Number</th></tr></thead>
          <tbody>
            ${coveredNumbers.map(n => `<tr><td>${n}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>

      <div class="section">
        <h3>üö´ Not Covered Numbers (${uncoveredNumbers.length}/${POSSIBLE_NUMBERS.length})</h3>
        <table class="table" border="1" cellpadding="5">
          <thead><tr><th>Number</th></tr></thead>
          <tbody>
            ${uncoveredNumbers.map(n => `<tr><td>${n}</td></tr>`).join("")}
          </tbody>
        </table>
      </div>
    `;

    // Badge
    badge.className = "status-badge " + (isArb ? "status-arb" : "status-notarb");
    badge.textContent = `${isArb ? "ARB ‚úÖ" : "NOT ARB ‚ùå"} (${coveragePercent.toFixed(2)}%)`;

  } catch (err) {
    result.innerHTML = `<p>‚ö†Ô∏è Error parsing FT JSON: ${err.message}</p>`;
    badge.className = "status-badge status-warning";
    badge.textContent = "Error";
  }
}

// ---------- fantan kingmaker ----------
if (game === "ft") {
  ftBetAnalyzer(jsonText, result, badge);
}



}

</script>



</body></html>